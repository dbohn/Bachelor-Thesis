#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 503
\begin_document
\begin_header
\origin unavailable
\textclass scrartcl
\begin_preamble
\usepackage{minted}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language ngerman
\language_package default
\inputencoding utf8
\fontencoding default
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation 0bp
\quotes_language german
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Section
Implementierung und Messung
\end_layout

\begin_layout Subsection
Das Maß
\end_layout

\begin_layout Standard
Ziel der Arbeit ist die Implementierung eines generischen Gossiping-Frameworks,
 das auf den Knoten des IoT-Labs ausgeführt werden kann, und die Evaluierung
 dieses Frameworks durch eine Anwendung, mit der die Nachrichtenverteilzeit
 einer Nachricht durch den Gossiping-Algorithmus bestimmt werden kann.
\end_layout

\begin_layout Standard
Die Nachrichtenverteilzeit sei die Zeit, die eine Information benötigt,
 um von einem Knoten 
\begin_inset Formula $s\in V$
\end_inset

 an alle weiteren Knoten in 
\begin_inset Formula $V\setminus\left\{ s\right\} $
\end_inset

 verteilt zu werden.
\end_layout

\begin_layout Standard
Wie auch in 
\begin_inset CommandInset citation
LatexCommand cite
key "6042051"

\end_inset

 angemerkt, wird die Nachrichtenverteilzeit maßgeblich durch die Gossiping-Perio
de 
\begin_inset Formula $\Delta t$
\end_inset

 bestimmt und ist nicht direkt von der Latenz der Kommunikation abhängig.
\end_layout

\begin_layout Standard
Dies folgt schon aus Anforderung 5, die in Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Anforderungen-Gossiping"

\end_inset

 an einen Gossiping-Algorithmus gestellt wurde.
\end_layout

\begin_layout Standard
Es wurde dort definiert, dass die Periode 
\begin_inset Formula $\Delta t$
\end_inset

 größer sein muss als die Zeit, die der Nachrichtenaustausch der Knoten
 benötigt, um eine Überlagerung der Runden zu verhindern.
\end_layout

\begin_layout Standard
Um also die Nachrichtenverteilzeit bestimmen zu können, muss ermittelt werden,
 wie viele Gossiping-Runden durchgeführt werden müssen bis alle Knoten die
 Nachricht erhalten.
\end_layout

\begin_layout Standard
Für einen Push-Pull-Algorithmus kann daher nach Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Push-Pull-PP"

\end_inset

 die folgende Nachrichtenverteilzeit 
\begin_inset Formula $T$
\end_inset

 erwartet werden:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
T & \le & \Delta t\left(\log_{3}n+O\left(\ln\ln n\right)\right)
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Subsubsection
Ermittlung der Nachrichtenverteilzeit
\end_layout

\begin_layout Standard
Die Ermittlung der Nachrichtenverteilzeit lässt sich also darauf reduzieren,
 die Anzahl der Runden zu ermitteln, die der Gossiping-Algorithmus benötigt,
 um die Nachricht im gesamten Netzwerk zu verteilen.
\end_layout

\begin_layout Standard
Die einzige Möglichkeit, mit einem einzelnen Knoten von außen zu interagieren
 und Daten zu aggregieren, ist eine serielle Schnittstelle, die über den
 Host-Knoten auf einen TCP-Port geleitet wird (siehe Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Schnittstellen-IoT"

\end_inset

).
 Dieser TCP-Port kann dann über das SSH-Frontend abgerufen werden.
\end_layout

\begin_layout Standard
Algorithmus 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Pseudocode-Rundenanzahl"

\end_inset

 zeigt den Algorithmus, der auf der Seite des SSH-Frontends ermittelt, wie
 viele Runden vergangen sind.
\end_layout

\begin_layout Standard
Dabei wird davon ausgegangen, dass ein Knoten, sobald er infiziert wurde,
 eine entsprechende Nachricht über die serielle Schnittstelle ausgibt, die
 die derzeitige Rundennummer enthält.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Enumerate
erstelle eine Menge 
\begin_inset Formula $S$
\end_inset

 aller Knoten
\end_layout

\begin_layout Enumerate
Solange 
\begin_inset Formula $S$
\end_inset

 nicht leer ist:
\end_layout

\begin_deeper
\begin_layout Enumerate
Warte auf Nachrichten von allen seriellen Schnittstellen der Knoten
\end_layout

\begin_layout Enumerate
Wenn eine Nachricht von Knoten 
\begin_inset Formula $k$
\end_inset

 empfangen wurde und diese Nachricht über die Aktualisierung des Caches
 ist:
\end_layout

\begin_deeper
\begin_layout Enumerate
entferne 
\begin_inset Formula $k$
\end_inset

 aus 
\begin_inset Formula $S$
\end_inset


\end_layout

\begin_layout Enumerate
merke dir die übermittelte Rundennummer, solange sie größer ist als die
 größte bisher bekannte.
\end_layout

\end_deeper
\end_deeper
\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Pseudocode-Rundenanzahl"

\end_inset

Pseudocode zur Ermittlung der Rundenanzahl
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Dieser Algorithmus geht davon aus, dass eine solche Nachricht nur ausgegeben
 wird, wenn der Knoten die vollständige Information erhalten hat.
 Des Weiteren geht dieses Verfahren nicht auf den Inhalt des Caches ein.
 Sollte also zu Beginn mehrere Knoten mit unterschiedlichen Werten infiziert
 sein, ist dieser Algorithmus dafür nicht nutzbar.
\end_layout

\begin_layout Standard
Im Rahmen dieser Arbeit wurde deshalb davon ausgegangen, dass nur ein Knoten
 zu Beginn infiziert ist, weshalb eine Betrachtung des Cache-Inhalts entfallen
 kann.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:neighbourhood-relationship"

\end_inset

Konstruktion der Nachbarschaftsrelation
\end_layout

\begin_layout Standard
Wird ein Knoten gestartet, so weiß er nicht, welche Knoten sich in direkter
 Nachbarschaft zu ihm befinden.
 Dies liegt erstmal in der Natur der Sache, da es sich dabei um drahtlose
 Sensorknoten handelt, die also keine direkte Verbindung zu anderen Knoten
 haben.
\end_layout

\begin_layout Standard
Wie aber in den vorherigen Abschnitten schon dargestellt ist die Nachbarschaftsr
elation aber ein wichtiges Konzept des Gossiping.
 Also ist es zur Implementierung dessen notwendig, diese Relation für jeden
 Knoten zu bestimmen.
\end_layout

\begin_layout Standard
Im ersten Schritt muss also ein Knoten auf sich aufmerksam machen, also
 den Knoten in seiner Umgebung von seiner Existenz berichten.
\end_layout

\begin_layout Standard
Der verwendete 802.15.4 Funkstandard erlaubt entweder den Versand einer Nachricht
 an einen einzelnen Knoten oder aber einer Broadcast-Nachricht, die von
 jedem Knoten empfangen wird, den das Signal in einer Form erreicht, dass
 er es decodieren kann.
\end_layout

\begin_layout Standard
Da der Knoten ja noch keine weiteren Knoten kennt, ist eine Broadcast-Nachricht
 die einzige Möglichkeit, die ihm bleibt, um sich damit anderen Knoten vorzustel
len.
\end_layout

\begin_layout Standard
Eine wünschenswerte Anforderung bei der Konstruktion dieser Nachbarschaftsrelati
on ist auch eine physische Nachbarschaft der Knoten.
 Das heißt, ein Knoten sollte nur die Nachbarn in seiner näheren Umgebung
 als Nachbarn kennen, mit denen er auch sicher kommunizieren kann.
\end_layout

\begin_layout Standard
Jedoch ist eine solche Anforderung nicht einfach umzusetzen.
 Wie 
\noun on
Baccour
\noun default
 et al.
 in 
\begin_inset CommandInset citation
LatexCommand cite
key "Baccour:2012:RLQ:2240116.2240123"

\end_inset

 feststellen, ist der Übertragungsbereich eines drahtlosen Sensorknotens
 nicht isotrop, das heißt nicht als einfache zirkulare Form um den Knoten
 annehmbar, in dem Pakete zuverlässig übertragen werden können, sondern
 lässt sich in drei Bereiche aufteilen: Der 
\begin_inset Quotes gld
\end_inset


\emph on
connected region
\emph default

\begin_inset Quotes grd
\end_inset

, die die Anforderungen einer qualitativ hochwertigen und stabilen Funkverbindun
g mit anderen Knoten erfüllt, einer 
\begin_inset Quotes gld
\end_inset


\emph on
transitional region
\emph default

\begin_inset Quotes grd
\end_inset

, in der Knoten auf lange Sicht nicht unbedingt stabil sind, und der 
\begin_inset Quotes gld
\end_inset


\emph on
disconnected region
\emph default

\begin_inset Quotes grd
\end_inset

, die für die Datenübertragung ungeeignet ist, da eine zuverlässige Datenübertra
gung nicht oder kaum möglich ist.
\end_layout

\begin_layout Standard
Die 
\begin_inset Quotes gld
\end_inset

transitional region
\begin_inset Quotes grd
\end_inset

 ist dabei von großer Problematik, da deren Dimension nicht unbedingt im
 Zusammenhang mit der Distanz zum Sender steht und dazu noch asymmetrisch
 ist.
 Nach 
\begin_inset CommandInset citation
LatexCommand cite
key "Baccour:2012:RLQ:2240116.2240123"

\end_inset

 weisen Kanäle in diesem Bereich einen stark schwankenden Anteil des erfolgreich
en Paketempfangs zwischen 10% und 90% auf, welcher als 
\emph on
Packet Reception Ratio
\emph default
 bezeichnet wird und als Verhältnis zwischen der Anzahl der erfolgreich
 empfangenen Pakete zu der Anzahl der versendeten Pakete definiert ist.
\end_layout

\begin_layout Standard
Wenn also ein Knoten eine Broadcast-Nachricht erhält, macht es durchaus
 Sinn, nicht blind den Absender als Nachbarn hinzuzufügen, sondern noch
 weitere Metriken einfließen zu lassen.
 Die Implementierung des Funktreibers des IoT-Lab Moduls gibt uns zwei Werte,
 die der Knoten zur Entscheidungsfindung verwenden kann:
\end_layout

\begin_layout Description
RSSI
\begin_inset space \space{}
\end_inset

(Remote
\begin_inset space \space{}
\end_inset

Signal
\begin_inset space \space{}
\end_inset

Strength
\begin_inset space \space{}
\end_inset

Indicator) Der RSSI-Wert gibt den Leistungspegel in dBm (Dezibel Milliwatt)
 an, mit der ein Signal empfangen wurde, und dabei sowohl negative als auch
 positive Werte annehmen kann.
\end_layout

\begin_layout Description
LQI
\begin_inset space \space{}
\end_inset

(Link
\begin_inset space \space{}
\end_inset

Quality
\begin_inset space \space{}
\end_inset

Indicator) Der Link Quality Indicator ist bereits in Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:PHY-Layer"

\end_inset

 vorgestellt worden.
 Die konkrete Implementierung ist aber dem Chip-Hersteller überlassen, so
 lange der Wertebereich zwischen 
\begin_inset Formula $0x00$
\end_inset

 und 
\begin_inset Formula $0xff$
\end_inset

 liegt.
 Der verwendete Chipsatz AT86RF231 definiert den LQI so, dass er sich auf
 die 
\begin_inset Quotes gld
\end_inset


\emph on
packet error rate
\emph default

\begin_inset Quotes grd
\end_inset

 (PER) abbilden lässt, welche das Verhältnis zwischen fehlerhaften empfangenen
 Paketen zur gesamten Anzahl an empfangenen Paketen darstellt.
 Diese Korrelation lässt sich natürlich erst nach vielen übertragenen Paketen
 herstellen.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /Users/davidbohn/Bachelor-Thesis/images/PER-vs-LQI-cut.pdf
	width 75col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Korrelation zwischen LQI und PER des AT86RF231-Chipsatzes nach vielen Transaktio
nen (Abbildung 8.6 in 
\begin_inset CommandInset citation
LatexCommand cite
key "AT86RF231"

\end_inset

)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die Implementierung verwendet primär den RSSI-Wert, kann aber auch auf den
 LQI-Wert geändert werden, da die Metrik des RSSI-Wertes transparenter ist
 und eine direkte physikalische Beziehung hat.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: umformulieren
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nun könnten allen Knoten diese Nachricht ja gleichzeitig versenden wollen,
 was dazu führt, dass die meisten dieser Broadcast-Nachrichten verloren
 gehen, da hier nicht sichergestellt wird, dass die Pakete auch wirklich
 empfangen werden und die Knoten so natürlich in sehr kurzer Zeit eine sehr
 große Last abzuarbeiten haben und so unter Umständen nicht einmal empfangsberei
t für alle Pakete sind.
\end_layout

\begin_layout Standard
Da dieser Schritt nicht Gegenstand der Messungen ist, sieht die Implementierung
 hierbei als Lösung vor, dass der Knoten von außen dazu aufgefordert wird,
 nach seinen Nachbarn zu suchen.
 Somit können alle Knoten einzeln die Suche starten und die Überlagerung
 von Nachrichten oder der Verlust sollte kein Problem darstellen.
\end_layout

\begin_layout Subsection
Implementierung des Gossiping-Frameworks
\end_layout

\begin_layout Subsubsection
Generisches Framework
\end_layout

\begin_layout Standard
Diese Arbeit umfasst die Implementierung eines generischen Gossiping-Frameworks,
 das sich an dem in 
\begin_inset CommandInset citation
LatexCommand cite
key "6042051,5290827"

\end_inset

 vorgestellten theoretischen Framework orientiert, das bereits in Algorithmus
 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Gossiping-Framework-nach-Bakhshi"

\end_inset

 als Pseudocode vorgestellt wurde.
\end_layout

\begin_layout Standard
Am Ende soll also ein Framework implementiert werden, dass lediglich drei
 Methoden bereitstellt, die implementiert werden müssen, um einen konkreten
 Algorithmus zu implementieren, der das Gossiping-Protokoll verwendet: eine
 Methode zur Auswahl des Nachbarn (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RandomPeer()
\end_layout

\end_inset

), mit dem in der aktuellen Runde kommuniziert werden soll, eine Methode
 zur Vorbereitung der Nachricht (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

PrepareMsg()
\end_layout

\end_inset

) sowie eine Methode, die anhand des eigenen Caches und einer empfangenen
 Nachricht entsprechende Änderungen am eigenen Cache vornimmt (
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Update()
\end_layout

\end_inset

).
 
\end_layout

\begin_layout Standard
Es ist jedoch nicht möglich, das Framework eins zu eins für einen IoT-Lab-Knoten
 zu implementieren.
\end_layout

\begin_layout Standard
Hauptpunkt ist dabei, dass das receive-Konstrukt, das vom Knoten-Betriebssystem
 bereitgestellt wird, sich deutlich anders verhält als in Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Methoden-zur-Kommunikation"

\end_inset

 definiert wurde.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsubsection
Implementierung des Testalgorithmus
\end_layout

\begin_layout Itemize
Package besteht aus Cache Frame und Frame ID
\end_layout

\begin_layout Subsection
Steuerungssoftware
\end_layout

\begin_layout Subsection
Auswertung
\end_layout

\begin_layout Itemize
Mal gucken, was so rauskommt
\end_layout

\end_body
\end_document
