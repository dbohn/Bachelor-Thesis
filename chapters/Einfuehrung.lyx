#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 503
\begin_document
\begin_header
\origin unavailable
\textclass scrartcl
\begin_preamble
\usepackage{minted}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language ngerman
\language_package default
\inputencoding utf8
\fontencoding default
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "cmtt" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation 0bp
\quotes_language german
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Section
Grundlagen verteilter Systeme
\end_layout

\begin_layout Standard
In diesem Kapitel werden notwendige Definitionen vorgestellt, die im Folgenden
 zur Beschreibung des Gossiping-Algorithmus und zur Diskussion der Implementieru
ng verwendet werden.
\end_layout

\begin_layout Standard
Dazu wird zunächst die mathematische Darstellung eines verteilten Systems
 beschrieben, wie sie im Rahmen dieser Arbeit angenommen wird.
\end_layout

\begin_layout Subsection
Beschreibung eines drahtlosen Sensornetzwerks
\end_layout

\begin_layout Standard
Verteilte Systeme lassen sich durch ungerichtete Graphen der Form 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

 beschreiben.
 Dabei sei die Knotenmenge 
\begin_inset Formula $V$
\end_inset

 die Menge aller Sensoren sowie 
\begin_inset Formula $E\subseteq V\times V$
\end_inset

 die Menge aller Kanäle zwischen den Knoten.
\end_layout

\begin_layout Standard
Ein Kanal 
\begin_inset Formula $\{u,v\}\in E$
\end_inset

 mit 
\begin_inset Formula $u,v\in V$
\end_inset

 beschreibt dabei eine bidirektionale Nachbarschaftsrelation zwischen zwei
 Knoten.
 Dies bedeutet, dass sowohl der Knoten 
\begin_inset Formula $u$
\end_inset

 den Knoten 
\begin_inset Formula $v$
\end_inset

 als auch reziprok der Knoten 
\begin_inset Formula $v$
\end_inset

 dem Knoten 
\begin_inset Formula $u$
\end_inset

 kennt und diesem Nachrichten schicken kann.
\end_layout

\begin_layout Standard
Des Weiteren beschreibe die Funktion 
\begin_inset Formula $lq\,:\,E\rightarrow\mathbb{R}$
\end_inset

 die Übertragungsqualität eines Kanals.
 Dabei sei sie so definiert, dass sie einen Vergleich über die Verlässlichkeit
 verschiedener Kanäle zulasse.
\end_layout

\begin_layout Standard
Wir werden diese Funktion genauer im Abschnitt 
\begin_inset CommandInset ref
LatexCommand eqref
reference "subsec:neighbourhood-relationship"

\end_inset

 betrachten.
\begin_inset Note Note
status open

\begin_layout Plain Layout
vielleicht hier weglassen oder zumindest umschreiben!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Damit können wir nun die Nachbarschaft 
\begin_inset Formula $N\left(v\right)$
\end_inset

 eines Knoten 
\begin_inset Formula $v$
\end_inset

 als die Menge aller Knoten beschreiben, die von einem Knoten via eines
 Kanals direkt erreichbar sind:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\mathcal{N}\left(v\right) & = & \left\{ u\in V|\left\{ v,u\right\} \in E\right\} 
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Es kann sinnvoll sein, die Nachbarschaft noch einzuschränken, indem man
 einen Grenzwert für 
\begin_inset Formula $lq\left(\left\{ u,v\right\} \right)$
\end_inset

 festlegt, d.h.
 nur Kanäle zulässt, die eine bestimmte Qualität haben.
\begin_inset Note Note
status open

\begin_layout Plain Layout
sollte man das noch machen?
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Methoden zur Kommunikation zwischen Knoten
\end_layout

\begin_layout Standard
Nach der Konstruktion des Netzwerks können die Knoten nun entsprechend Daten
 austauschen.
\begin_inset Note Note
status open

\begin_layout Plain Layout
asynchrones (nicht-blockierendes) send, blockierendes receive
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In den folgenden theoretischen Betrachtungen verwenden wir dafür die Operationen
 
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

send
\end_layout

\end_inset

 und 
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

receive
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Ein Knoten 
\begin_inset Formula $v$
\end_inset

 kann nur eine Nachricht an einen Nachbarn 
\begin_inset Formula $p$
\end_inset

 aus 
\begin_inset Formula $N\left(v\right)$
\end_inset

 schicken.
 Die sende-Operation erfolgt asynchron, d.h.
 der Sender wird nicht blockiert bis der Empfänger die Nachricht erhalten
 hat.
 Eine solche Sende-Operation einer Nachricht 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

m
\end_layout

\end_inset

 an einen Nachbarn 
\begin_inset Formula $p$
\end_inset

 beschreiben wir in unseren theoretischen Betrachtungen mit:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

send m to p
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Auf der Empfangsseite muss ein Knoten sich explizit empfangsbereit zeigen.
 Er wartet dabei nicht auf eine Nachricht von einem bestimmten Kanal, sondern
 ist für Nachrichten auf allen Kanälen offen.
\end_layout

\begin_layout Standard
Eine Empfangsoperation ist blockierend, das heißt der empfangende Knoten
 kann in dieser Zeit keine anderen Befehle ausführen.
\end_layout

\begin_layout Standard
Im Pseudocode wird im Folgenden der Nachrichtenempfang in einen Puffer
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b
\end_layout

\end_inset

 wie folgt dargestellt:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

receive b
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Zunächst gehen wir prinzipiell davon aus, dass auf diesen Kanälen keine
 Nachrichten verloren gehen.
 Da dies aber auf den betrachteten drahtlosen Kanälen äußerst unwahrscheinlich
 ist, werden wir diesem Fall einen eigenen Abschnitt widmen.
\end_layout

\begin_layout Section
Der Gossiping-Algorithmus
\end_layout

\begin_layout Standard
In diesem Kapitel wird nun zunächst die Grundidee des Gossiping-Algorithmus
 vorgestellt und dann konkrete Umsetzungen dieses Verfahrens dargestellt.
 Der Abschnitt wird mit der Vorstellung, verschiedener Algorithmen abgeschlossen
, die den Gossiping-Algorithmus verwenden, um die folgende Vorstellung der
 Implementierung zu motivieren.
\end_layout

\begin_layout Subsection
Die Grundidee
\end_layout

\begin_layout Standard
Die Grundidee dieses Algorithmus steckt schon in seinem Namen: Informationen
 werden 
\begin_inset Quotes gld
\end_inset

tratschend
\begin_inset Quotes grd
\end_inset

 (dt.
 für to gossip) verbreitet.
 Man stelle sich folgende Situation vor: In einem Büro mit 
\begin_inset Formula $N$
\end_inset

 Mitarbeitern erhält Mitarbeiter 
\begin_inset Formula $i$
\end_inset

 die Nachricht, dass zum Ende des Jahres einige Mitglieder gekündigt werden.
 Dies ist natürlich eine Nachricht von solcher Prägnanz, dass er diese seinen
 beiden Kollegen, die ihm im Büro gegenübersitzen, sofort mitteilen muss.
 Somit sind auch diese beiden Kollegen im Besitz dieser Information, die
 sie dann wieder weiter an einige wenige Kollegen tragen.
 Somit verbreitet sich die Nachricht schnell mit einer Konstante beschränktem
 Aufwand pro Mitarbeiter im ganzen Netzwerk.
\end_layout

\begin_layout Standard
Im Kontext der verteilten Systeme ersetzen wir nun die Mitarbeiter nun durch
 Knoten und die möglichen Kollegen, mit denen ein Mitarbeiter kommunizieren
 kann, stellen wir durch Kanäle zwischen verschiedenen Knoten dar.
\end_layout

\begin_layout Standard
Erhält ein Knoten neue Informationen, sei es durch äußere Einwirkungen oder
 durch Beendigung einer Berechnung, so wird er diese an eine zufällige Teilmenge
 seiner Nachbarn verteilen, welche ebenfalls wieder jeweils eine Teilmenge
 von eigenen Nachbarn auswählen und mit diesen einen Gossip durchführen.
\end_layout

\begin_layout Standard
Somit wird in relativ wenigen Schritten die Information im gesamten Netzwerk
 verteilt.
\end_layout

\begin_layout Standard
Diese informelle Beschreibung wird im Folgenden nun formal beschrieben.
 Das Ergebnis werden zwei Protokolle sein, die sich in ihrer Formulierung
 unterscheiden, aber dieselbe Idee und Funktionalität teilen.
\end_layout

\begin_layout Subsection
Algorithmus auf Grundlage eines zentralen Tick
\begin_inset Note Note
status open

\begin_layout Plain Layout
Vielleicht anders strukturieren
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Der Gossiping-Algorithmus stammt aus der Klasse der epidemischen Algorithmen.
 Die Idee der epidemischen Algorithmen, die von 
\noun on
Demers
\noun default
 et al.
 in 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Quelle: Epidemic Algorithms for Replicated Database Maintenance
\end_layout

\end_inset

 vorgestellt wurde, beruht auf der epidemischen Verbreitung von Viren und
 anderer Krankheitserreger, die von den Virologen beobachtet wurde.
\end_layout

\begin_layout Standard
Dabei wurde beobachtet, dass Wirte und Zwischenwirte, d.h.
 Lebewesen, die bereits mit einem Virus infiziert sind, mit bestimmten Wahrschei
nlichkeiten diese Viren an empfängliche Knoten weitergeben.
\end_layout

\begin_layout Standard
Diese Beobachtung ist sehr ähnlich zu dem Algorithmus, den wir modellieren
 wollen, weshalb im Folgenden eine ähnliche Nomenklatur zur Beschreibung
 der Knotenzustände verwendet wird.
\end_layout

\begin_layout Subsubsection
Knotenzustände
\end_layout

\begin_layout Standard
Ein Knoten 
\begin_inset Formula $v$
\end_inset

 ist zu jedem Zeitpunkt in einem dieser drei Zustände:
\end_layout

\begin_layout Description
infiziert
\begin_inset space \space{}
\end_inset

(infected) Der Knoten besitzt eine Information, die er an andere Knoten
 weitergeben kann, und wird dies von nun an versuchen.
\end_layout

\begin_layout Description
empfänglich
\begin_inset space \space{}
\end_inset

(susceptible) Der Knoten besitzt noch keine neuen Informationen, er ist
 also für die Information anderer Knoten empfänglich.
\end_layout

\begin_layout Description
entfernt(removed) Der Knoten ist nicht mehr als Empfänger verfügbar, aber
 ist auch nicht mehr in einem Zustand, dass er Informationen weitergeben
 kann.
\end_layout

\begin_layout Subsubsection
Synchronisation
\end_layout

\begin_layout Standard
Betrachten wir erneut die allgemeine Beschreibung des Verfahrens, so erkennt
 man schnell, dass der Datenaustausch in Phasen erfolgt.
 Also zunächst ein Knoten verteilt seine Daten an einen Nachbarn und erst
 im Anschluss wird dieser Nachbar aktiv.
 Es liegt also nahe, den Gossiping-Algorithmus rundenbasiert zu beschreiben,
 um einen konsistenten Zustand zu bewahren.
 Dies stellt eine erhebliche Erleichterung dar.
 Wir schränken dadurch die Menge der Absendeknoten eines Pakets auf die
 infizierten Nachbarn zum Zeitpunkt des Rundenbeginns ein.
 In einer Runde fällt jeder Knoten einmalig die Entscheidung, Informationen
 weiterzugeben oder nicht und führt dann entsprechende Aktionen durch.
\end_layout

\begin_layout Standard
Die Initiierung einer solchen Runde ist der Hauptunterschied zwischen den
 beiden Beschreibungen der Algorithmen, die hier vorgestellt werden.
\end_layout

\begin_layout Standard
Zunächst nehmen wir eine externe Taktquelle an.
 Diese muss für unsere Zwecke nicht weiter beschrieben werden, als dass
 sie allen Knoten mehr oder weniger gleichzeitig das Signal gibt, dass jetzt
 eine neue Runde beginnt.
 Eine Möglichkeit ist dabei, dass dieses Signal von einem Knoten im Netzwerk
 
\begin_inset Formula $G$
\end_inset

 generiert wird, der einen Kanal zu allen anderen Knoten im Netzwerk besitzt
 (siehe dazu z.B.
 die Topologie in 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Netz-zentral-Takt"

\end_inset

).
\end_layout

\begin_layout Subsubsection
Ablauf einer Runde
\end_layout

\begin_layout Standard
In jeder Runde 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /Users/davidbohn/Bachelor-Thesis/images/3-2-tick-network.pdf
	scale 80

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Netz-zentral-Takt"

\end_inset

Netzwerk 
\begin_inset Formula $G$
\end_inset

 mit zentralem Taktgeber T (rot markiert)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Beschreibung des Gossiping Algorithmus bzw.
 der Klasse der epidemischen Algorithmen
\end_layout

\begin_layout Itemize
Vorstellung des Prototyp-Algorithmus, der als Blaupause dient
\end_layout

\begin_deeper
\begin_layout Itemize
Vergleich mit Formulierung über zentralen Tick
\end_layout

\end_deeper
\begin_layout Itemize
Abgrenzung
\end_layout

\begin_deeper
\begin_layout Itemize
Push
\end_layout

\begin_layout Itemize
Pull
\end_layout

\begin_layout Itemize
Push-Pull
\end_layout

\end_deeper
\begin_layout Section
Technische Infrastruktur
\end_layout

\begin_layout Standard
Vor der Betrachtung der eigentlichen Implementierung wird im folgenden Abschnitt
 die technische Infrastruktur, die zur Realisierung verwendet wurde.
\end_layout

\begin_layout Standard
Dabei handelt es sich um das IoT-Lab, eine Experimentierplattform für drahtlose
 Sensornetze, die über verschiedene Standorte in Frankreich verteilt ist.
\end_layout

\begin_layout Subsection
Das IoT-Lab
\end_layout

\begin_layout Itemize
Was ist das IoT-Lab?
\end_layout

\begin_layout Itemize
Welche Hardware stellt es zur Verfügung?
\end_layout

\begin_layout Itemize
Workflow?
\end_layout

\begin_layout Subsection
Der 802.15.4 Funkstandard
\end_layout

\begin_layout Itemize
Was ist Teil des Standards, was nicht?
\end_layout

\begin_layout Itemize
Anwendungsgebiet
\end_layout

\end_body
\end_document
