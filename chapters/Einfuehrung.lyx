#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 503
\begin_document
\begin_header
\origin unavailable
\textclass scrartcl
\begin_preamble
\usepackage{minted}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language ngerman
\language_package default
\inputencoding utf8
\fontencoding default
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "cmtt" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation 0bp
\quotes_language german
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Section
Grundlagen und Nomenklatur
\end_layout

\begin_layout Standard
In diesem Kapitel werden notwendige Definitionen vorgestellt, die im Folgenden
 zur Beschreibung des Gossiping-Algorithmus und zur Diskussion der Implementieru
ng verwendet werden.
\end_layout

\begin_layout Standard
Dazu wird zunächst die mathematische Darstellung eines verteilten Systems
 beschrieben, wie sie im Rahmen dieser Arbeit angenommen wird, und im Anschluss
 die Kommunikationsmechanismen der Knoten vorgestellt.
\end_layout

\begin_layout Subsection
Beschreibung eines drahtlosen Sensornetzwerks
\end_layout

\begin_layout Standard
Verteilte Systeme lassen sich durch ungerichtete Graphen der Form 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

 beschreiben.
 Dabei sei die Knotenmenge 
\begin_inset Formula $V$
\end_inset

 die Menge aller Sensoren sowie 
\begin_inset Formula $E\subseteq V\times V$
\end_inset

 die Menge aller Kanäle zwischen den Knoten.
\end_layout

\begin_layout Standard
Ein Kanal 
\begin_inset Formula $\{u,v\}\in E$
\end_inset

 mit 
\begin_inset Formula $u,v\in V$
\end_inset

 beschreibt dabei eine bidirektionale Nachbarschaftsrelation zwischen zwei
 Knoten.
 Dies bedeutet, dass sowohl der Knoten 
\begin_inset Formula $u$
\end_inset

 den Knoten 
\begin_inset Formula $v$
\end_inset

 als auch analog der Knoten 
\begin_inset Formula $v$
\end_inset

 den Knoten 
\begin_inset Formula $u$
\end_inset

 kennt und diesem Nachrichten schicken kann.
\end_layout

\begin_layout Standard
Die Nachbarschaft 
\begin_inset Formula $N\left(v\right)$
\end_inset

 eines Knoten 
\begin_inset Formula $v$
\end_inset

 sei die Menge aller Knoten, die vom Knoten 
\begin_inset Formula $v$
\end_inset

 via eines Kanals direkt erreichbar sind:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
\mathcal{N}\left(v\right) & : & V\rightarrow\mathcal{P}\left(E\right)\nonumber \\
\mathcal{N}\left(v\right) & = & \left\{ \begin{array}{c|c}
u\in V & \left\{ v,u\right\} \in E\end{array}\right\} \label{eq:neighbourhood-definition}
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Subsection
Methoden zur Kommunikation zwischen Knoten
\end_layout

\begin_layout Standard
Nach der Konstruktion des Netzwerks können die Knoten nun entsprechend Daten
 austauschen.
\end_layout

\begin_layout Standard
In den folgenden theoretischen Betrachtungen werden dafür die Operationen
 
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

send
\end_layout

\end_inset

 und 
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

receive
\end_layout

\end_inset

 verwendet.
\end_layout

\begin_layout Standard
Ein Knoten 
\begin_inset Formula $v$
\end_inset

 kann nur eine Nachricht an einen Nachbarn 
\begin_inset Formula $p$
\end_inset

 aus 
\begin_inset Formula $N\left(v\right)$
\end_inset

 schicken.
 Die 
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

send
\end_layout

\end_inset

-Operation sei dabei asynchron, das heißt der Absender wird nicht blockiert
 bis der Empfänger die Nachricht erhalten hat und kann sofort weiteren Code
 ausführen.
 Eine solche 
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

send
\end_layout

\end_inset

-Operation einer Nachricht 
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

m
\end_layout

\end_inset

 an einen Nachbarn 
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 wird durch die folgende Syntax in den theoretischen Betrachtungen dargestellt:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

send m to p
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Damit der Empfänger eine Nachricht erhalten kann, muss er dies explizit
 durch Verwendung der 
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

receive
\end_layout

\end_inset

-Operation ankündigen.
\end_layout

\begin_layout Standard
Eine Empfangsoperation ist blockierend, das heißt der empfangende Knoten
 kann in dieser Zeit keine anderen Befehle ausführen und wartet so lange
 bis eine Nachricht eintrifft.
\end_layout

\begin_layout Standard
Im Pseudocode wird im Folgenden der Nachrichtenempfang in einen Puffer 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b
\end_layout

\end_inset

 wie folgt dargestellt:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

receive b
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Um herauszufinden, wer der Absender der empfangen Nachricht ist, wird die
 Funktion 
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

sender(b)
\end_layout

\end_inset

 auf den Puffer angewandt.
\end_layout

\begin_layout Standard
Für die Gossiping-Anwendung wird es nützlich sein, ein Konstrukt zur Verfügung
 zu haben, mit dem man lediglich Nachrichten von einem bestimmten Nachbarn
 empfangen kann, weshalb das folgende Konstrukt hier kurz vorgestellt sei:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

receive b from p
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Dieser Aufruf blockiert den aufrufenden Knoten so lange, bis eine Nachricht
 von dem angegebenen Knoten 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 empfangen wurde.
 Andere Nachrichten von anderen Knoten werden in diesem Falle verworfen.
\end_layout

\begin_layout Standard
Dadurch wird die Semantik der eigentlichen Operationen nicht verfälscht,
 da es sich dabei nur um eine syntaktische Ergänzung handelt.
 Das Verhalten ließe sich leicht mittels einer Schleife und der 
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

sender
\end_layout

\end_inset

-Funktion auch durch einfache 
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

receive
\end_layout

\end_inset

 Aufrufe darstellen.
\end_layout

\begin_layout Section
Der Gossiping-Algorithmus
\end_layout

\begin_layout Standard
In diesem Kapitel wird nun zunächst die Grundidee des Gossiping-Algorithmus
 vorgestellt und dann konkrete Umsetzungen dieses Verfahrens dargestellt.
 Hauptsächlich werden dabei Aspekte beleuchtet, die für die Nachrichtenverteilze
it von Relevanz sind.
 Somit ist für uns vor allem von Interesse, wann die Information im gesamten
 Netzwerk verteilt ist bzw.
 wann der Gossiping-Algorithmus terminiert.
\end_layout

\begin_layout Standard
Diese theoretischen Überlegungen werden durch praktische Betrachtungen zum
 Anwendungszweck des Algorithmus und konkreten Beispielen ergänzt und somit
 die Implementierung motiviert.
\end_layout

\begin_layout Subsection
Die Grundidee
\end_layout

\begin_layout Standard
Die Grundidee dieses Algorithmus ist schon durch den Namen gegeben: Informatione
n werden 
\begin_inset Quotes gld
\end_inset

tratschend
\begin_inset Quotes grd
\end_inset

 (dt.
 für to gossip) verbreitet.
\end_layout

\begin_layout Standard
Als Beispiel diene die folgende Geschichte: In einem Büro mit einer festen
 Anzahl von Mitarbeitern erhält Mitarbeiter ein Mitarbeiter die Nachricht,
 dass zum Ende des Jahres einige Mitglieder gekündigt werden.
 Dies ist natürlich eine Nachricht von solcher Prägnanz, dass er diese sofort
 einem Kollegen mitteilt, der ihm im Büro gegenübersitzt.
 Somit ist auch dieser Kollege im Besitz dieser Information, die er dann
 wieder weiter an weitere Kollegen verbreitet.
 Somit verbreitet sich die Nachricht schnell mit beschränktem Aufwand pro
 Mitarbeiter im ganzen Netzwerk, obwohl der erste Mitarbeiter nicht einmal
 alle anderen Mitarbeiter kennen musste.
\end_layout

\begin_layout Standard
Im Kontext der verteilten Systeme seien die Mitarbeiter nun Knoten und die
 möglichen Kollegen, mit denen ein Mitarbeiter kommunizieren kann, seien
 durch die Kanäle zwischen den Knoten gegeben, also durch die Nachbarschaftsrela
tion 
\begin_inset Formula $\mathcal{N}\left(v\right)$
\end_inset

.
\end_layout

\begin_layout Standard
Erhält ein Knoten neue Informationen, sei es durch äußere Einwirkungen oder
 durch Beendigung einer Berechnung, so wird er diese an eine zufällige Teilmenge
 seiner Nachbarn verteilen, welche ebenfalls wieder jeweils eine Teilmenge
 von eigenen Nachbarn auswählen und mit diesen einen Gossip durchführen.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Anforderungen-Gossiping"

\end_inset

Anforderungen an einen Gossiping-Algorithmus
\end_layout

\begin_layout Standard
Im Folgenden wird ein Algorithmus im Folgenden als Gossiping-Algorithmus
 bezeichnet, wenn er die folgenden Anforderungen, die von 
\noun on
Birman
\noun default
 in 
\begin_inset CommandInset citation
LatexCommand cite
key "Birman:2007:PLG:1317379.1317382"

\end_inset

 vorgeschlagen wurden, erfüllt.
\end_layout

\begin_layout Enumerate
Kern des Protokolls sind periodische und paarweise Interaktionen zwischen
 verschiedenen Prozessen.
\end_layout

\begin_layout Enumerate
Die Information, die durch in Punkt 1 beschriebene Interaktionen versendet
 wird, ist von beschränkter Größe.
\end_layout

\begin_layout Enumerate
Wenn zwei Prozesse interagieren, ändert sich der Zustand eines oder beider
 Prozesse insofern, dass es den Status des anderen reflektiert.
\end_layout

\begin_layout Enumerate
Eine verlässliche Kommunikation wird nicht vorausgesetzt.
\end_layout

\begin_layout Enumerate
Die Interaktionsfrequenz ist im Vergleich zu den Latenzen des Nachrichtenaustaus
chs gering.
\end_layout

\begin_layout Enumerate
Die Auswahl des Nachbarknotens, mit dem interagiert wird, geschieht auf
 irgendeine Art und Weise zufällig.
\end_layout

\begin_layout Paragraph
Zu 1.
\end_layout

\begin_layout Standard
Dieser Punkt besagt vor allem, dass ein Prozess nach einer Interaktion mit
 einem anderen Prozess eine gewisse Zeit wartet, bis er erneut Daten sendet.
 Diese Periodendauer ist gleich für alle Prozesse.
 Jede Interaktion findet dabei nur mit einem weiteren Prozess statt.
\end_layout

\begin_layout Paragraph
Zu 2.
\end_layout

\begin_layout Standard
Jede Nachricht, die zwischen Knoten ausgetauscht wird, lässt sich durch
 eine globale obere Schranke in ihrer Größe beschränken.
 Das bedeutet, dass Gossiping vor allem dafür gedacht ist, kleinere Datenmengen
 in einem Netzwerk zu verteilen.
\end_layout

\begin_layout Paragraph
Zu 3.
\end_layout

\begin_layout Standard
Wenn also ein Prozess eine Nachricht von einem anderen Prozess erhält, so
 muss der Inhalt dieser Nachricht die Entscheidung den eigenen Zustand zu
 ändern motivieren.
 Ein Beispiel für einen Verstoß gegen diese Regel wäre, wenn der Prozess
 diese Nachricht nur dazu nutzen würde, um die Zeit zu berechnen, die benötigt
 wird, um eine Nachricht zwischen den beiden Knoten hin und her zu tauschen.
\end_layout

\begin_layout Paragraph
Zu 4.
\end_layout

\begin_layout Standard
Dieser Punkt ist einer der großen Stärken von Gossiping Algorithmen in drahtlose
n Sensornetzwerken, in denen Knoten wegen äußerer Einwirkungen nicht immer
 unbedingt verfügbar sind oder Nachrichten nicht empfangen werden können.
 Dies heißt im Prinzip, dass der Algorithmus nicht davon aufgehalten werden
 darf, wenn er einen bestimmten Nachbarknoten nicht erreichen kann.
\end_layout

\begin_layout Paragraph
Zu 5.
\end_layout

\begin_layout Standard
Dieser Punkt steht in direktem Zusammenhang mit dem ersten Punkt.
 Die periodischen Interaktionen ermöglichen es, den Ablauf des Gossiping-Algorit
hmus in Runden einzuteilen und somit den Ablauf des Algorithmus klar rekonstruie
ren zu können.
 Wäre jetzt die Zeit zwischen den Interaktionen kleiner als die maximale
 Dauer des Nachrichtenaustausches, so würde ein Knoten bereits eine neue
 Interaktion initiieren, bevor die vorherige überhaupt abgeschlossen ist
 und er seinen Zustand entsprechend anpassen konnte.
\end_layout

\begin_layout Paragraph
Zu 6.
\end_layout

\begin_layout Standard

\noun on
Birman
\noun default
 stellt hier eine weniger strikte Anforderung, da für ihn kein Nachbarknoten
 ausgewählt werden muss.
 Durch die Konstruktion eines entsprechenden Overlays, das alle erreichbaren
 Knoten eines Knotens zu einem Nachbarknoten macht, zeigt aber, dass die
 Definition dadurch nicht eingeschränkt wurde.
 Da in den drahtlosen Sensornetzwerken aber vor allem die Nachbarn als Kommunika
tionspartner in Frage kommen, wurde das Kriterium entsprechend angepasst.
\end_layout

\begin_layout Standard
Dieses Zufallskriterium spielt auch stark mit der vierten Anforderung zusammen,
 da der Algorithmus dadurch nicht abhängig davon ist, diesen nicht erreichbaren
 Knoten zu kontaktieren, anders als bei einem deterministischen Algorithmus,
 der zu jedem Zeitpunkt einen klar definierten Nachbarn zurückgibt.
\end_layout

\begin_layout Subsection
Gossiping als epidemischer Algorithmus
\end_layout

\begin_layout Standard
Der Gossiping-Algorithmus, oftmals auch als Rumor Spreading-Algorithmus
 bezeichnet, wird der Klasse der epidemischen Algorithmen zugeordnet.
 Die Idee der epidemischen Algorithmen, die von 
\noun on
Demers
\noun default
 et al.
 in 
\begin_inset CommandInset citation
LatexCommand cite
key "Demers:1987:EAR:41840.41841"

\end_inset

 vorgestellt wurde, beruht auf den mathematischen Modellen der epidemischen
 Verbreitung von Viren und anderer Krankheitserreger, die von Virologen
 verwendet wird, um die Verbreitung von Krankheitserregern vorauszusagen.
\end_layout

\begin_layout Standard
Während aber der Virologe gemeinhin versucht, die Verbreitung des Virus
 möglichst einzudämmen, so möchte man bei epidemischen Algorithmen hingegen
 einen Verlauf gestalten, der eine möglichst schnelle Verbreitung der Informatio
nen gewährleistet.
\end_layout

\begin_layout Subsubsection
Knotenzustände
\end_layout

\begin_layout Standard
Wir betrachten zunächst, welche Zustände ein Knoten in unserem Netzwerk
 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

 haben kann.
 Diese Zustände werden in 
\begin_inset CommandInset citation
LatexCommand cite
key "Demers:1987:EAR:41840.41841"

\end_inset

 vorgeschlagen und sind der Epidemologie entnommen.
 Jeder Knoten 
\begin_inset Formula $v\in V$
\end_inset

 hat zu jedem Zeitpunkt einen dieser drei Zustände:
\end_layout

\begin_layout Description
infiziert
\begin_inset space \space{}
\end_inset

(infected) Der Knoten besitzt eine Information, die er an andere Knoten
 weitergeben kann und will, und wird dies von nun an versuchen.
\end_layout

\begin_layout Description
empfänglich
\begin_inset space \space{}
\end_inset

(susceptible) Der Knoten besitzt noch keine neuen Informationen, er ist
 also für die Information anderer Knoten empfänglich.
\end_layout

\begin_layout Description
entfernt(removed) Der Knoten hat die neuen Informationen erhalten, will
 diese aber nicht mehr weiter verbreiten.
\end_layout

\begin_layout Standard
Im Folgenden sei 
\begin_inset Formula $I$
\end_inset

 die Menge der infizierten Knoten in 
\begin_inset Formula $V$
\end_inset

, 
\begin_inset Formula $S$
\end_inset

 die Menge der empfänglichen Knoten und 
\begin_inset Formula $R$
\end_inset

 die Menge der entfernten Knoten:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
I & = & \left\{ \begin{array}{c|c}
v\in V & v\text{ ist infiziert}\end{array}\right\} \\
S & = & \left\{ \begin{array}{c|c}
v\in V & v\text{ ist empfänglich}\end{array}\right\} \\
R & = & \left\{ \begin{array}{c|c}
v\in V & v\text{ ist entfernt}\end{array}\right\} 
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Da jeder Knoten höchstens einen Zustand haben darf, gilt:
\begin_inset Formula 
\begin{eqnarray}
I\cap S\cap R & = & \emptyset\label{eq:subsetcut}
\end{eqnarray}

\end_inset

Jeder Knoten muss aber auch einen dieser drei Zustände haben, so dass 
\begin_inset Formula 
\begin{eqnarray}
I\cup S\cup R & = & V\label{eq:subsetconjunct}
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Modellierung-von-Gossiping"

\end_inset

Modellierung von Gossiping als epidemischer Algorithmus
\end_layout

\begin_layout Standard
Wir betrachten nun, wie das Rumor Spreading (also Gossiping), nach 
\begin_inset CommandInset citation
LatexCommand cite
key "Demers:1987:EAR:41840.41841"

\end_inset

 als epidemischer Algorithmus beschrieben werden kann.
\end_layout

\begin_layout Standard
Ein Knoten 
\begin_inset Formula $v\in I$
\end_inset

, d.h.
 ein Knoten im Zustand 
\emph on
infiziert
\emph default
, wählt fortlaufend einen Knoten aus 
\begin_inset Formula $\mathcal{N}\left(v\right)$
\end_inset

 aus und schickt ihm seine neuen Informationen.
 Der Empfänger antwortet mit seinen bisherigen Informationen.
\end_layout

\begin_layout Standard
Kannte der Empfänger die Informationen bereits, so hört der Knoten 
\begin_inset Formula $v$
\end_inset

 mit Wahrscheinlichkeit 
\begin_inset Formula $\frac{1}{k}$
\end_inset

 auf, Informationen auszutauschen und geht in den Zustand 
\emph on
entfernt
\emph default
 über.
\end_layout

\begin_layout Standard
Ein empfänglicher Knoten, der Informationen erhält, geht in den Zustand
 
\emph on
infiziert
\emph default
 über und beginnt nun ebenfalls einen zufälligen Nachbarn auszuwählen und
 diesem die eigene Information mitzuteilen.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /Users/davidbohn/Bachelor-Thesis/images/3-2-infection-states.pdf
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Zustandsübergänge beim Gossiping beschrieben als epidemischen Vorgang (eigene
 Abbildung)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Analyse-von-diesem"

\end_inset

Analyse von diesem Gossiping-Modell
\end_layout

\begin_layout Standard
Das lässt nun die Frage aufkommen, wann das System in einen Zustand kommt,
 in dem keine weiteren Nachrichten ausgetauscht werden.
\end_layout

\begin_layout Standard
Wir nehmen hierbei an, dass die Kanäle zwischen den Knoten verlustfrei sind
 und die Sende- und Empfangsoperationen atomar sind.
 Dies sind gerade in drahtlosen Sensornetzen sehr starke Einschränkungen,
 die aber zu der Zeit und für den Anwendungszweck von 
\noun on
Demers 
\noun default
et al.
 hinnehmbar waren.
\end_layout

\begin_layout Standard
Dazu betrachten wir, wie sich die Anteile der 
\emph on
infizierten
\emph default
, 
\emph on
empfänglichen
\emph default
 und 
\emph on
entfernten
\emph default
 Knoten an der gesamten Knotenmenge 
\begin_inset Formula $V$
\end_inset

 über die Zeit ändert.
 Sei 
\begin_inset Formula $i=\frac{\left|I\right|}{\left|V\right|}$
\end_inset

 der Anteil der infizierten Knoten, 
\begin_inset Formula $s=\frac{\left|S\right|}{\left|V\right|}$
\end_inset

 der Anteil der empfänglichen Knoten sowie 
\begin_inset Formula $r=\frac{\left|R\right|}{\left|V\right|}$
\end_inset

 der Anteil der entfernten Knoten.
 Aus 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:subsetcut"

\end_inset

 und 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:subsetconjunct"

\end_inset

 folgt daher:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
i+r+s & = & 1\label{eq:epidemic-fractionsum}
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
Nach 
\begin_inset CommandInset citation
LatexCommand cite
key "Demers:1987:EAR:41840.41841"

\end_inset

 lässt sich die Verbreitung der Information nun über zwei Differentialgleichunge
n beschreiben:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
\frac{ds}{dt} & = & -s\cdot i\label{eq:susceptible-change}\\
\frac{di}{dt} & = & s\cdot i-\frac{1}{k}\left(1-s\right)\cdot i\label{eq:infected-change}
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
Gleichung 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:susceptible-change"

\end_inset

 beschreibt dabei die Änderung des Anteils der Empfänglichen Knoten an 
\begin_inset Formula $V$
\end_inset

 pro Zeiteinheit.
 Das Produkt beschreibt dabei, den Anteil der Empfänglichen, die von den
 infizierten Knoten ausgewählt werden und die neue Information erhalten,
 dadurch verlassen sie den Zustand 
\emph on
empfänglich
\emph default
, weshalb diese Menge immer abnimmt.
\end_layout

\begin_layout Standard
Analog haben wir den reziproken Term in Gleichung 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:infected-change"

\end_inset

, da diese Knoten ja nun 
\emph on
infiziert
\emph default
 sind und diese Menge dadurch größer wird.
 Zusätzlich gibt es aber noch den Fall, dass ein infizierter Knoten einen
 Knoten kontaktiert hat, der die Information bereits kennt.
 Wie oben beschrieben hört dieser dann mit Wahrscheinlichkeit 
\begin_inset Formula $\frac{1}{k}$
\end_inset

 auf, die Nachricht zu verteilen und ist dann nicht mehr 
\emph on
infiziert
\emph default
, sondern geht in den Zustand 
\emph on
entfernt
\emph default
 über.
 Der Anteil der Knoten, die nicht empfänglich sind, d.h.
 bei denen diese Entscheidung stattfindet, ist durch 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:epidemic-fractionsum"

\end_inset

 als 
\begin_inset Formula $1-s$
\end_inset

 gegeben.
\end_layout

\begin_layout Standard
Wir wollen nun geeignete Werte für 
\begin_inset Formula $k$
\end_inset

 finden, die eine möglichst zuverlässige Verteilung der Daten im Netz sicherstel
lt.
 Zur Lösung wird dazu in 
\begin_inset CommandInset citation
LatexCommand cite
key "Demers:1987:EAR:41840.41841"

\end_inset

 das Verhältnis 
\begin_inset Formula $\frac{di}{ds}$
\end_inset

 gebildet.
 Dadurch entfernen wir die zeitliche Komponente und erhalten:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\frac{di}{ds} & = & -\frac{s\cdot i-\frac{1}{k}\left(1-s\right)\cdot i}{s\cdot i}\\
 & = & -1+\frac{\left(1-s\right)\cdot i}{k\cdot s\cdot i}\\
 & = & -1+\frac{i-s\cdot i}{k\cdot s\cdot i}\\
 & = & -1+\frac{\cancel{i}}{k\cdot s\cdot\cancel{i}}-\frac{\cancel{s\cdot i}}{k\cdot\cancel{s\cdot i}}\\
 & = & -\frac{k+1}{k}+\frac{1}{k\cdot s}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Dadurch können wir nun über Integration eine Funktion 
\begin_inset Formula $i\left(s\right)$
\end_inset

 erhalten, die uns für einen Anteil an empfänglichen Knoten einen Anteil
 an infizierten Knoten bestimmt:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
i\left(s\right) & = & -\frac{k+1}{k}s+\frac{1}{k}\ln s+c\label{eq:i-nach-integration}
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
Für große Knotenmengen 
\begin_inset Formula $V$
\end_inset

 konvergiert 
\begin_inset Formula $c$
\end_inset

 gegen den folgenden Wert:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
c & = & \frac{k+1}{k}
\end{eqnarray*}

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
Vielleicht etwas ausbauen....
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Durch Einsetzen in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:i-nach-integration"

\end_inset

 erhalten wir somit:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
i\left(s\right) & = & \frac{k+1}{k}\left(1-s\right)+\frac{1}{k}\ln s\label{eq:i-depend-on-s}
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
Zur Bestimmung der Anzahl der empfänglichen Knoten, bei denen es keine infiziert
en Knoten mehr gibt, also das System inaktiv geworden ist, wird diese Funktion
 null gesetzt, was die folgende implizite Gleichung für die Anzahl der Empfängli
chen Knoten ergibt:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
s & = & e^{-\left(k+1\right)\left(1-s\right)}\label{eq:development-of-s}
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
Diese Gleichung ist lediglich von 
\begin_inset Formula $k$
\end_inset

 und von sich selbst abhängig, weshalb es eine implizite Gleichung ist.
\end_layout

\begin_layout Standard
In Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Anteil-empfänglicher-Knoten"

\end_inset

 ist das Verhalten der Gleichung bei sich änderndem 
\begin_inset Formula $k$
\end_inset

 dargestellt.
 Der erste Term des Exponenten 
\begin_inset Formula $k+1$
\end_inset

 ist der dominante Term, weshalb dieser den Kurvenverlauf maßgeblich vorgibt.
 Der zweite Term (
\begin_inset Formula $1-s$
\end_inset

) ist stets im Intervall 
\begin_inset Formula $\left[0,1\right]$
\end_inset

 und wird somit schnell vom Term 
\begin_inset Formula $k+1$
\end_inset

 verdrängt, weshalb die Abbildung einen guten Ansatzpunkt liefert.
\end_layout

\begin_layout Standard
Wird somit zum Beispiel 
\begin_inset Formula $k=1$
\end_inset

 gewählt, d.h.
 ein infizierter Knoten geht sofort in den Zustand entfernt über, sobald
 er einen nicht empfänglichen Knoten kontaktiert, so sind am Ende noch ca.
 
\begin_inset Formula $20\%$
\end_inset

 der Knoten empfänglich, haben also die Information nicht bekommen und können
 sie auch nicht mehr erhalten.
 Wird 
\begin_inset Formula $k$
\end_inset

 aber auf 
\begin_inset Formula $2$
\end_inset

 erhöht, so sind dies lediglich nur noch 
\begin_inset Formula $6\%$
\end_inset

 der Knoten, die die Information nicht erhalten.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways true
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/davidbohn/Bachelor-Thesis/images/3-2-decay.pdf
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Anteil-empfänglicher-Knoten"

\end_inset

Anteil empfänglicher Knoten nach Entfernung des letzten Infizierten über
 
\begin_inset Formula $k$
\end_inset

 (eigene Abbildung)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Anti-Entropie
\end_layout

\begin_layout Standard
Ein beinahe noch einfacherer Ansatz ist die Anti-Entropie, die ebenfalls
 in 
\begin_inset CommandInset citation
LatexCommand cite
key "Demers:1987:EAR:41840.41841"

\end_inset

 vorgestellt wird.
 Die Idee hierbei ist, dass die Knoten in periodischen Abständen untereinander
 einen Abgleich der Daten durchführen.
 Somit entfällt das Entfernen der Knoten mit Wahrscheinlichkeit 
\begin_inset Formula $\frac{1}{k}$
\end_inset

, wenn der kontaktierte Partner bereits die Daten kannte.
\end_layout

\begin_layout Standard
In jeder Periode wählt ein Knoten also einen anderen Knoten aus und tauscht
 mit diesem Informationen aus.
 Dabei gibt es drei verschiedene Möglichkeiten: Entweder schickt er lediglich
 seine Daten an seinen ausgewählten Nachbarn (
\emph on
push
\emph default
), fordert die Daten des Nachbarn an (
\emph on
pull
\emph default
) oder schickt seine Daten und erwartet die des Nachbarn (
\emph on
push-pull
\emph default
).
\end_layout

\begin_layout Standard
Ein großer Nachteil im Vergleich zum vorherigen Ansatz ist die hohe Belastung
 des Funkmediums, da jeder Knoten, auch wenn er keine aktuellen Informationen
 kennt, also empfänglich ist, seine Daten regelmäßig über das Netz an einen
 anderen Knoten verteilt.
\end_layout

\begin_layout Subsubsection
Push, Pull und Push-Pull
\end_layout

\begin_layout Standard
Bereits im vorherigen Abschnitt wurden die verschiedenen Arten des Datenaustausc
hs bei Verwendung eines Anti-Entropie-Algorithmus vorgestellt.
 Diese lassen sich nicht nur auf die Anti-Entropie anwenden, sondern auch
 auf den in Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Modellierung-von-Gossiping"

\end_inset

 und 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Analyse-von-diesem"

\end_inset

 vorgestellten Algorithmus.
 So kann auch ein empfänglicher Knoten z.B.
 mit einer bestimmten Wahrscheinlichkeit einen Nachbarknoten nach seinen
 Informationen fragen und damit einen 
\emph on
pull
\emph default
 durchzuführen.
 Wenn dieser ein infizierter Knoten war, wird er dadurch selbst infiziert
 und fängt damit an Nachrichten per 
\emph on
push
\emph default
 an andere Knoten zu verteilen.
 Neben dieser Mischform ist es auch möglich, eine reine pull-Strategie durchzufü
hren, indem nur die empfänglichen Knoten die infizierten anfragen.
\end_layout

\begin_layout Standard
Interessanterweise weisen push, pull und push-pull unterschiedliche Charakterist
ika auf, die sich vor allem in der Geschwindigkeit der Informationsverbreitung
 widerspiegeln.
\end_layout

\begin_layout Minisec
Push
\end_layout

\begin_layout Standard
Jeder infizierte Knoten leitet in diesem Fall seine Information pro Runde
 an genau einen anderen Knoten weiter.
 Initial sind wenige Knoten infiziert (beim rumor spreading genau einer)
 und die Chance, einen Knoten zu finden, der die Nachricht bereits erhalten
 hat.
 Somit wächst die Menge der Infizierten nach 
\noun on
Karp
\noun default
 et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "892324"

\end_inset

 zunächst exponentiell bis ungefähr die Hälfte (
\begin_inset Formula $\frac{n}{2}$
\end_inset

) der Knoten infiziert ist.
 Anschließend nimmt die Zahl der empfänglichen Knoten um einen konstanten
 Faktor ab.
 In jeder Runde empfangen dann nämlich ungefähr 
\begin_inset Formula $\frac{1}{e}$
\end_inset

 Knoten keine Nachricht.
 Aus diesem Grund werden nach der exponentiellen Phase 
\begin_inset Formula $\Theta\left(\ln n\right)$
\end_inset

 Runden benötigt bis alle Knoten die Nachricht empfangen haben.
 
\noun on
Pittel
\noun default
 ermittelte in 
\begin_inset CommandInset citation
LatexCommand cite
key "10.2307/2101696"

\end_inset

 sogar eine Anzahl von 
\begin_inset Formula $\log_{2}\left(n\right)+\ln\left(n\right)+O\left(1\right)$
\end_inset

 Runden bis alle Knoten die Nachricht erhalten haben.
\end_layout

\begin_layout Minisec
Pull
\end_layout

\begin_layout Standard
In diesem Fall ist die initiale Verbreitung der Information deutlich langsamer,
 da in den ersten Runden der infizierte Knoten bzw.
 die infizierten Knoten nicht unbedingt kontaktiert wurden.
 Nach 
\begin_inset CommandInset citation
LatexCommand cite
key "892324"

\end_inset

 sind nach 
\begin_inset Formula $O\left(\ln n\right)$
\end_inset

 Runden mit hoher Wahrscheinlichkeit 
\begin_inset Formula $\frac{n}{2}$
\end_inset

 Knoten infiziert.
 Aber ab diesem Punkt verbessert sich die Verteilung der Nachricht deutlich
 im Vergleich zum Push-Algorithmus, der ab diesem Punkt nur noch konstant
 viele Knoten höchstens neu infiziert.
 Seien zu Beginn der Runde 
\begin_inset Formula $s\cdot n$
\end_inset

 Knoten empfänglich, wobei 
\begin_inset Formula $s$
\end_inset

 wie oben der Anteil der empfänglichen Knoten sei, dann gilt für jeden empfängli
chen Knoten, dass er in dieser Runde mit Wahrscheinlichkeit 
\begin_inset Formula $1-s$
\end_inset

 infiziert wird.
 Daraus ergibt sich ein Erwartungswert von 
\begin_inset Formula $s^{2}n$
\end_inset

 empfängliche Knoten nach Ende der Runde.
 Also werden nach der Infektion der halben Population nur noch 
\begin_inset Formula $\Theta\left(\ln\ln n\right)$
\end_inset

 Runden benötigt, um alle Knoten zu infizieren.
 Insgesamt werden also 
\begin_inset Formula $O\left(\ln n\right)+\Theta\left(\ln\ln n\right)$
\end_inset

 Runden benötigt, um alle Knoten zu infizieren.
\end_layout

\begin_layout Minisec
Push-Pull
\end_layout

\begin_layout Standard
Während der Datenaustausch per 
\emph on
push
\emph default
 für bis zu 
\begin_inset Formula $\frac{n}{2}$
\end_inset

 infizierten Knoten deutlich schneller funktioniert als pull, funktioniert
 letzteres deutlich besser ab diesem Punkt als 
\emph on
push
\emph default
.
 Es liegt also nahe, beide Varianten in ein Verfahren zu kombinieren, um
 somit auch die Stärken zu kombinieren.
 
\begin_inset CommandInset citation
LatexCommand cite
key "892324"

\end_inset

 unterteilt die Dissemination in vier Phasen.
 Zunächst kennt nur ein Knoten die neuen Informationen.
 Die Wahrscheinlichkeit, dass er in 
\begin_inset Formula $c$
\end_inset

 Runden mindestens einen empfänglichen Knoten kontaktiert hat, also nicht
 sich selbst, ist 
\begin_inset Formula $1-n^{-c}$
\end_inset

, weshalb sich mit hoher Wahrscheinlichkeit die Anzahl der Infizierten nach
 
\begin_inset Formula $c$
\end_inset

 Runden verdoppelt hat.
 Somit sind nach 
\begin_inset Formula $O\left(\ln\ln n\right)$
\end_inset

 Runden 
\begin_inset Formula $\left(\ln n\right)^{4}$
\end_inset

 Knoten infiziert.
 Ab diesem Punkt beginnt eine stark exponentielle Verbreitung der Information.
 Diese dauert an bis ungefähr 
\begin_inset Formula $\frac{n}{\ln n}$
\end_inset

 Knoten infiziert sind.
 Dafür werden 
\begin_inset Formula $\log_{3}n\pm O\left(\ln\ln n\right)$
\end_inset

 Runden benötigt.
 Die beiden letzten Phasen beschreiben zunächst eine quadratische Abnahme
 und das Ausklingen durch Infektion der verbliebenen Knoten.
 Beide Phasen benötigen aber lediglich 
\begin_inset Formula $O\left(\ln\ln n\right)$
\end_inset

 Runden.
 Somit erreicht Push-Pull nach 
\begin_inset CommandInset citation
LatexCommand cite
key "892324"

\end_inset

 eine komplette Verteilung der Daten in etwa 
\begin_inset Formula $\log_{3}n+O\left(\ln\ln n\right)$
\end_inset

 Runden.
\end_layout

\begin_layout Subsubsection
Fazit
\end_layout

\begin_layout Standard
Wird der Algorithmus also auf diese Weise implementiert, so ist nicht unbedingt
 sichergestellt, dass am Ende alle Knoten die Nachricht erhalten haben.
 Es kann in einigen Anwendungen verkraftbar sein, dass dieser Fall eintritt.
 Wir möchten aber hier gerade die Zeit analysieren, bis alle Knoten die
 Nachricht erhalten haben.
\end_layout

\begin_layout Standard
Des Weiteren hat dieser Ansatz das Problem, dass er verlässliche Datenkanäle
 annimmt.
 Eine solche Annahme ist aber für drahtlose Sensornetzwerke nicht haltbar,
 weshalb im Folgenden Möglichkeiten vorgestellt werden, wie man mit dieser
 Problematik umgehen kann.
\end_layout

\begin_layout Subsection
Gossiping-Framework
\end_layout

\begin_layout Standard
Für die weiteren Betrachtungen des Gossiping-Algorithmus wird auf das Framework
 zurückgegriffen, das von 
\noun on
Bakhshi
\noun default
 et al.
 in 
\begin_inset CommandInset citation
LatexCommand cite
key "6042051,5290827"

\end_inset

 vorgestellt wurde.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},mathescape=true"
inline false
status open

\begin_layout Plain Layout

wait $
\backslash
Delta t$ time units;
\end_layout

\begin_layout Plain Layout

$p$ = RandomPeer();
\end_layout

\begin_layout Plain Layout

$
\backslash
sigma$ = PrepareMsg();
\end_layout

\begin_layout Plain Layout

send $
\backslash
sigma$ to $p$;
\end_layout

\begin_layout Plain Layout

wait until receive $
\backslash
sigma_p$ from $p$;
\end_layout

\begin_layout Plain Layout

Update($
\backslash
sigma$, $
\backslash
sigma_p$);
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},mathescape=true"
inline false
status open

\begin_layout Plain Layout

wait until receive $
\backslash
sigma_p$;
\end_layout

\begin_layout Plain Layout

$
\backslash
sigma$ = PrepareMsg();
\end_layout

\begin_layout Plain Layout

send $
\backslash
sigma$ to sender($
\backslash
sigma_p$);
\end_layout

\begin_layout Plain Layout

Update($
\backslash
sigma$, $
\backslash
sigma_p$);
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align center
a) aktiver Thread
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align center
b) passiver Thread
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Gossiping-Framework-nach-Bakhshi"

\end_inset

Gossiping-Framework nach 
\noun on
Bakhshi
\noun default
 et al.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Das Framework sieht vor, dass ein Knoten zwei Threads ausführt - einen aktiven
 und einen passiven Thread.
 Des Weiteren besitzt jeder Knoten einen lokalen Cache, der die Daten des
 Knotens beinhaltet, die durch das Gossiping verbreitet und verändert werden.
\end_layout

\begin_layout Standard
Der passive Thread ist dabei dafür zuständig, eine Nachricht von einem Nachbarn
 zu empfangen, mit dem eigenen Informationen im entsprechenden Cache-Segment
 zu antworten und den eigenen Cache entsprechend zu aktualisieren.
\end_layout

\begin_layout Standard
Der aktive Thread wird in einem festen Intervall 
\begin_inset Formula $\Delta t$
\end_inset

 ausgeführt.
 Alle Knoten verwenden dabei dasselbe Intervall.
 Alle 
\begin_inset Formula $\Delta t$
\end_inset

 Zeiteinheiten wählt der Knoten einen Nachbarn aus, wählt einen entsprechenden
 Teil des Caches (oder den ganzen) aus, schickt diesen an den Knoten und
 wartet auf die Antwort, die von dessem passiven Thread geschickt werden,
 um anhand dieser den eigenen Cache zu aktualisieren.
\end_layout

\begin_layout Standard
Die Funktionen 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RandomPeer()
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

PrepareMsg()
\end_layout

\end_inset

 und 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Update()
\end_layout

\end_inset

 sind dabei entsprechend davon abhängig, wie der Algorithmus genau funktionieren
 soll, also wofür man den Gossiping-Algorithmus verwenden will.
\end_layout

\begin_layout Standard
Die Funktion 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RandomPeer()
\end_layout

\end_inset

 wählt aus der Menge 
\begin_inset Formula $N\left(v\right)$
\end_inset

 einen Vertreter aus.
 Diese Auswahl muss eine zufällige Komponente beinhalten.
 Eine Auswahl des Caches wird mit der Funktion 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

PrepareMsg()
\end_layout

\end_inset

 generiert.
 In manchen Anwendungen ist der Cache nicht weiter unterteilbar, weil er
 z.B.
 aus nur einem Wert besteht, dann wird immer der gesamte Cache übertragen.
 Andererseits kann durch entsprechende Definition der 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

PrepareMsg()
\end_layout

\end_inset

 Funktion auch eine Pull-Strategie realisiert werden, indem man ein leeres
 Cache-Element verschickt, auf das der passive Thread dann mit seinen Daten
 antwortet.
\end_layout

\begin_layout Standard
Die Aktualisierung des eigenen Caches bei Empfang eines Datenpakets geschieht
 in der 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Update()
\end_layout

\end_inset

-Funktion.
 Über diese Funktion lässt sich an diesem Punkt nicht mehr sagen, als dass
 sie Anforderung Nr.
 3 aus Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Anforderungen-Gossiping"

\end_inset

 erfüllen muss, das heißt sie darf den eigenen Cache nur insofern ändern,
 dass diese Änderung auf Basis des empfangenen Pakets geschieht.
\end_layout

\begin_layout Standard
Die weiteren Anforderungen 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Anforderungen-Gossiping"

\end_inset

 werden bei vorsichtiger Definition der drei eben beschriebenen Funktionen
 ebenfalls durch das Framework erfüllt.
\end_layout

\begin_layout Standard
Der aktive Thread stellt sicher, dass es eine periodische, paarweise Interaktion
 zwischen den Prozessen gibt.
 Solange das von 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

PrepareMsg()
\end_layout

\end_inset

 generierte Paket eine maximale Größe hat, so wird auch die Anforderung
 Nr.
 2 erfüllt, dass der Datenaustausch immer eine maximale Größe hat.
\end_layout

\begin_layout Standard
Auch Anforderung Nr.
 4 wird von diesem Ansatz erfüllt, da davon ausgegangen wird, dass ein Knoten
 sich nicht merkt, mit welchen Nachbarn er bereits interagiert hat oder
 zumindest irgendwann wieder Kontakt mit diesen aufnehmen wird, wenn man
 den Algorithmus nur lange genug laufen lässt.
\end_layout

\begin_layout Standard
Der einzige Haken hierbei ist Zeile 5 des aktiven Threads.
 In dieser wartet ein Prozess so lange, bis er eine Antwort von einem Prozess
 bekommt.
 Hier ein infinites Warten vorauszusetzen ist nicht sinnvoll, sondern sollte
 eher durch einen timeout ergänzt werden, der leicht unter dem Intervall
 
\begin_inset Formula $\Delta t$
\end_inset

 liegt, um somit in der nächsten Runde wieder teilnehmen zu können.
\end_layout

\begin_layout Standard
Durch eine entsprechend große Wahl von 
\begin_inset Formula $\Delta t$
\end_inset

 wird auch Anforderung Nr.
 5 erfüllt, also dass die Frequenz des Austauschs deutlich geringer ist
 als die Latenz der Austauschs.
 Bei der praktischen Umsetzung muss dann dieser Wert entsprechend an die
 Hardware angepasst werden.
\end_layout

\begin_layout Standard
Anforderung Nr.
 6, die zufällige Auswahl der Kommunikationspartner, wird durch die Funktion
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RandomPeer()
\end_layout

\end_inset

 erfüllt, insofern sie der Spezifikation entsprechend implementiert wurde.
\end_layout

\begin_layout Subsection
Gossiping über unzuverlässige Kanäle
\end_layout

\begin_layout Standard
Gossiping-Algorithmen über unzuverlässige Kanäle stellen hohe Anforderungen
 an die Analyse, die oftmals auch stark vom implementierten Verfahren abhängen.
 Zur Analyse dieser Gossiping-Algorithmen existieren verschiedene Modelle,
 die jedoch alle wegen der Natur des Gossipings nicht um Konstrukte der
 Wahrscheinlichkeitsrechnung herumkommen.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: ausarbeiten
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Abgrenzung zur epidemischen Betrachtung
\end_layout

\begin_layout Section
Technische Infrastruktur
\end_layout

\begin_layout Standard
Vor der Betrachtung der eigentlichen Implementierung wird im folgenden Abschnitt
 die technische Infrastruktur, die zur Realisierung verwendet wurde.
\end_layout

\begin_layout Standard
Im Rahmen dieser Arbeit wurde eine Implementierung des Gossiping-Algorithmus
 für das IoT-Lab vorgenommen.
 Dabei handelt es sich um eine Experimentierplattform für drahtlose Sensornetzwe
rke von großer Dimension, das eine praktische Evaluation von verteilten
 Algorithmen in verschiedenen Szenarien ermöglicht.
\end_layout

\begin_layout Standard
Genauer betrachtet wird im Anschluss noch der Funkstandard, der für die
 drahtlose Kommunikation im IoT-Lab verwendet wird, da einige Eigenschaften
 des Standards die Implementierung beeinflusst haben.
\end_layout

\begin_layout Subsection
Das IoT-Lab
\end_layout

\begin_layout Standard
Das IoT-Lab ist eine Plattform, die von der französischen INRIA mit der
 Unterstützung verschiedener weiterer Universitäten in Europa betrieben
 wird.
\end_layout

\begin_layout Standard
Auf verschiedene Standorte in Frankreich sind dabei weit über 2000 Sensorknoten
 verteilt, die in drei Systemarchitekturen aufgeteilt werden können.
 Neben dem Typ WSN430 (diese Knoten wurden vom Vorgängerprojekt des IoT-Labs,
 dem SensLab, übernommen) und den A8-Knoten, die sogar ein vollständiges
 Linux ausführen können, ist vor allem eine große Anzahl an Knoten vom Typ
 M3 vorhanden.
\end_layout

\begin_layout Standard
Die Implementierung, die im Rahmen dieser Arbeit vorgenommen wurde, ist
 ausschließlich für diesen Knotentyp gedacht, weshalb allein dieser und
 der Arbeitsablauf mit diesem Knotentyp hier kurz vorgestellt wird.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /Users/davidbohn/Bachelor-Thesis/resources/m3opennode.png
	width 80col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Foto-M3-Knoten"

\end_inset

Fotografie eines M3-Knotens (Quelle 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Quelle: iot-lab.info
\end_layout

\end_inset

)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Hardware
\end_layout

\begin_layout Standard
Neben einer Reihe von Sensoren, die für diese Arbeit nicht verwendet wurden,
 ist das Board mit einem ARM-Mikroprozessor bestückt und verwendet einen
 802.15.4-Funkchip im 
\begin_inset Formula $2,4$
\end_inset

 GHz-Band zur Kommunikation.
\end_layout

\begin_layout Standard
Das Modul kann über den in Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Foto-M3-Knoten"

\end_inset

 gezeigten 
\begin_inset Quotes gld
\end_inset

IoT-LAB Connector
\begin_inset Quotes grd
\end_inset

 von außen mit neuen Programmen bestückt und gesteuert werden.
 Diese Schnittstelle fasst Stromversorgung und serielle Kommunikation zusammen
 und dient zur Verbindung mit einem so genannten Host-Knoten.
 Während die bisher vorgestellte Hardware von den Nutzern des IoT-Labs frei
 programmiert werden kann, ist der Zugriff auf den Host-Knoten nur eingeschränkt
 möglich.
 Dieser ist dafür verantwortlich, die Firmware auf die Knoten zu transportieren,
 den Knoten zu starten oder anzuhalten und auch den Energieverbrauch zu
 messen.
\end_layout

\begin_layout Subsubsection
Schnittstellen in das IoT-Lab
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /Users/davidbohn/Bachelor-Thesis/images/iot_lab-infra-full.jpg
	width 90col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Schnittstellen in das IoT-Lab (Quelle: IoT-Lab Website 
\begin_inset Note Note
status open

\begin_layout Plain Layout
https://www.iot-lab.info/tools/
\end_layout

\end_inset

)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In diesem Abschnitt werden die diversen Methoden zur Interaktion mit dem
 IoT-Lab bzw.
 dessen Knoten vorgestellt.
\end_layout

\begin_layout Standard
Primär stellt das IoT-Lab eine REST-ähnliche Schnittstelle zur Verfügung.
 Über diese können zunächst Experimente erstellt werden.
 Ein Experiment besteht aus einer Auswahl an Knoten, mit denen man arbeiten
 möchte, einer Zuordnung von Firmware-Dateien, die vom Nutzer hochgeladen
 werden können, zu den Knoten und noch einer Zuordnung von Profilen, die
 genutzt werden können, um Verbrauchsdaten von den Host-Knoten abzurufen.
 Dieses Experiment kann dann zu einem gewählten Zeitpunkt oder so schnell
 wie möglich gestartet werden.
 Zu diesen Experimenten können dann über die Schnittstelle auch weitere
 Informationen wie die verwendeten Knoten, den Status usw.
 abgerufen werden.
\end_layout

\begin_layout Standard
Da die Interaktion über die REST-Schnittstelle aber in der Regel zu umständlich
 ist, bietet das IoT-Lab hierfür auch eine zweckerfüllende Web-Oberfläche
 an.
\end_layout

\begin_layout Standard
Um in einem laufenden Experiment mit den Knoten zu interagieren, gibt es
 die Möglichkeit, sich via SSH mit einem Linux-Server im IoT-Lab zu verbinden.
\end_layout

\begin_layout Standard
Die oben beschriebenen Host-Knoten besitzen eine Ethernet-Schnittstelle,
 über die sie im Netzwerk erreichbar sind und unter anderem die serielle
 Schnittstelle des Knotens spiegeln, mit dem sie über den IoT-Lab Connector
 verbunden sind.
\end_layout

\begin_layout Standard
Diese lassen sich auf dem Linux-Server aggregieren und die Daten, die empfangen
 wurden verarbeiten, oder Daten an einen oder alle Knoten senden.
\end_layout

\begin_layout Standard
Das IoT-Lab stellt dafür eine Reihe von Tools und Bibliotheken zur Verfügung,
 die die Arbeit mit dieser Bibliothek vereinfachen.
\end_layout

\begin_layout Subsubsection
Betriebssystem der Knoten
\end_layout

\begin_layout Standard
Prinzipiell schreibt das IoT-Lab für die Knoten kein Betriebssystem vor,
 man könnte diese also auch ohne ein solches programmieren.
\end_layout

\begin_layout Standard
Das macht aber gerade die Arbeit mit der Hardware deutlich schwerer, weshalb
 es Portierungen verschiedener Betriebssysteme, die sich für ressourcensparende
 Echtzeit-Systeme eignen, gibt, die schon Treiber für die eingebauten Hardwareko
mponenten mitbringen.
 Die Knoten vom Typ A8 stechen hierbei heraus, da für diese sogar ein Port
 von Linux existiert.
 Aufgrund der vergleichsweise geringen Anzahl an verfügbaren Knoten und
 schlechteren Dokumentation, wird dies hier aber nicht verwendet.
\end_layout

\begin_layout Standard
Stattdessen gab es für die M3-Knoten drei Systeme, die hierfür in Frage
 kamen.
\end_layout

\begin_layout Description
RIOT RIOT
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://riot-os.org
\end_layout

\end_inset


\end_layout

\end_inset

 ist ein Echtzeit-Betriebssystem mit Multithreading, das für den Einsatz
 auf energiesparenden, verlässlichen und ressourcensparsamen Geräten des
 Internet of Things konzipiert wurde.
 Das Ziel ist dabei die Schaffung einer einheitlichen und einfach zu nutzenden
 API, die auf vielen Architekturen verwendet werden kann.
 Diese Eigenschaften und die Tatsache, dass die Entwicklung an RIOT von
 der Freien Universität Berlin stark vorangetrieben wird, machten es zuerst
 zu einem guten Kandidaten für die Verwendung.
 Jedoch waren die Treiber für die M3-Knoten zu Beginn der Implementierung
 noch nicht voll einsatzfähig, weshalb es nicht verwendet werden konnte.
\end_layout

\begin_layout Description
Contiki Contiki
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.contiki-os.org
\end_layout

\end_inset


\end_layout

\end_inset

 ist ebenfalls ein freies Betriebssystem, das auf die Verwendung in energiespare
nden und günstigen Mikrocontrollern ausgelegt ist.
 Jedoch liegen die Stärken des Systems vor allem darin, die Geräte in das
 Internet einzubinden, wofür es einen ausgereiften IP-Stack und verschiedene
 Funkprotokolle implementiert.
 Zusätzlich bietet es auch einen Simulator, der die Entwicklung von Anwendungen
 auf Basis des Systems deutlich vereinfacht.
 Jedoch ist auch die Dokumentation des IoT-Labs zu diesem Betriebssystem
 hauptsächlich auf die Einbindung eines Knotens in das Internet aus und
 es wird die Verwendung eines recht großen Protokollstacks erwartet, weshalb
 auch Contiki nicht verwendet wurde.
\end_layout

\begin_layout Description
FreeRTOS Zuletzt wurde das sehr kleine und leichtgewichtige Betriebssystem
 FreeRTOS
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.freertos.org
\end_layout

\end_inset


\end_layout

\end_inset

 betrachtet.
 Seine größte Stärke ist, dass es an sich aus wenigen Dateien besteht, aber
 es trotzdem die wichtigsten Funktionalitäten bereitstellt, die man von
 einem Betriebssystem auf solchen Systemen erwartet.
 Dazu gehören Mechanismen für Multithreading, ein Semaphor-Konstrukt und
 auch Software-Timer.
 Da es dazu noch sehr schnell ist, wurde es von den Betreuern des IoT-Lab
 zur primären Entwicklungsplattform für dieses gemacht und hat somit die
 besten Treiber für die Hardware des Knotens.
 Da zusätzlich auch weite Teile der Dokumentation auf FreeRTOS basieren,
 wurde dieses System für die Implementierung verwendet.
\end_layout

\begin_layout Subsection
Der 802.15.4 Funkstandard
\end_layout

\begin_layout Standard
Dieser Abschnitt stellt die grundlegenden Eigenschaften des 802.15.4 Funkstandards
 des IEEE vor.
 Als Grundlage dient dafür die Spezifikation der 
\begin_inset Quotes gld
\end_inset

Low-Rate Wireless Personal Area Networks
\begin_inset Quotes grd
\end_inset

 des IEEE vom 5.
 September 2011
\begin_inset CommandInset citation
LatexCommand cite
key "802.15.4"

\end_inset

.
\end_layout

\begin_layout Standard
Ein Wireless Personal Area Network (WPAN) dient dabei dazu energiesparend
 und günstig Informationen über relativ kurze Distanzen zu übertragen ohne
 dabei eine größere Infrastruktur vorauszusetzen wie beispielsweise beim
 Wireless Local Area Network (WLAN).
\end_layout

\begin_layout Standard
Der Standard definiert hierfür physikalische Schichten (PHY-Layer) für verschied
ene Frequenzbänder und die Zugriffskontrolle auf das Medium (medium access
 control/MAC-Layer).
 Die wichtigsten Frequenzbänder, die von dem Standard gedeckt werden und
 die in Deutschland von Relevanz sind, sind dabei das 868 MHz-Band sowie
 das 2,4 GHz-Band.
\end_layout

\begin_layout Standard
Es wird dabei zwischen zwei Typen von Netzwerkkomponenten unterschieden.
 Auf der einen Seite gibt es das Reduced Function Device (RFD), das nur
 sehr simple Aufgaben übernimmt.
 In einer Heimautomatisierungslösung kann dies z.B.
 ein Lichtschalter sein, der eben nur dann, wenn der Schalter gedrückt wurde,
 diese Änderung an einen so genannten Koordinator weiterleiten muss, oder
 eine Lampe, die dann angeht, wenn vom Koordinator eine entsprechende Nachricht
 kommt.
\end_layout

\begin_layout Standard
Dieser Koordinator ist zwangsläufig ein Full Function Device (FFD) und kann
 im Gegensatz zum RFD, das nur mit seinem zugeordneten FFD kommunizieren
 kann, mit all seinen Nachbarn in seinem Umkreis kommunizieren.
 Daher ist es für die Umsetzung des Gossiping-Algorithmus naheliegend, alle
 Knoten als Full Function Device anzusehen.
\end_layout

\begin_layout Subsubsection
Topologien
\end_layout

\begin_layout Standard
Es werden zwei mögliche Topologien vorgeschrieben.
\end_layout

\begin_layout Standard
Die Stern-Topologie sieht einen zentralen Koordinator-Knoten vor, der z.B.
 die Orchestrierung in einem Heimautomatisierungssystem übernimmt.
 Alle Knoten kennen nur diesen Koordinator, weshalb diese Topologie für
 ein drahtloses Sensornetzwerk ungeeignet ist.
\end_layout

\begin_layout Standard
Die zweite Topologie ist eine Peer-to-Peer-Topologie, die für das Anwendungsgebi
et der drahtlosen Sensornetze deutlich besser geeignet ist.
 Hierbei kommuniziert ein Knoten nicht nur mit dem Koordinator, den es trotzdem
 geben kann, sondern auch mit den Nachbarn, die er erreichen kann.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:PHY-Layer"

\end_inset

PHY-Layer
\end_layout

\begin_layout Standard
Die PHY-Layer ist zunächst nicht von großer Bedeutung für die Implementierung,
 wir benötigen jediglich einige Werte, die der PHY-Layer uns bereitstellt.
 Diese umfassen die Energy detection (ED) sowie der Link Quality Indicator
 (LQI).
 Die Energy Detection bestimmt die Signalstärke auf einem bestimmten Funkkanal
 ausgehend von einer minimalen Signalstärke.
 Das ist also die induzierte Energie durch die Datenübertragung.
 Dieser wird für weitere Protokollschichten, die in dem Standard definiert
 werden, benötigt.
 Der Link Quality Indicator dagegen ist eine Metrik, die für die Anwendungsschic
ht definiert wird und im PHY-Layer selbst nicht weiter verwendet wird, und
 soll die Stärke und Qualität der Funkübertragung bei Empfang eines Pakets
 charakterisiert werden.
 Daher wird diese Messung auch für jedes Paket durchgeführt und ergibt gleichmäß
ig verteilte Werte im Bereich von 
\begin_inset Formula $0x00$
\end_inset

 und 
\begin_inset Formula $0xff$
\end_inset

, die mit der niedrigsten bzw.
 höchsten Signalstärke belegt werden, die verwendbar sind.
 Zusätzlich definiert das Protokoll auch Methoden des 
\emph on
clear channel assessments
\emph default
, das heißt der Bestimmung, ob ein Funkkanal gerade belegt wird.
 Diese beziehen z.B.
 ein, ob der ED-Wert einen bestimmten Wert überschreitet, das heißt, dass
 irgendwas von einer bestimmten Stärke empfangen wird, oder auch, ob es
 auch ein valides Signal ist.
\end_layout

\begin_layout Subsubsection
MAC-Layer
\end_layout

\begin_layout Standard
Die Aufgabe des MAC-Layer ist es sicherzustellen, dass es nicht zu Kollisionen
 kommt, das heißt, dass ein Knoten ein Paket sendet, obwohl gerade ein anderes
 Paket übertragen wird, das dadurch beschädigt werden würde.
\end_layout

\begin_layout Standard
Es gibt eine Vielzahl von Algorithmen, um diese Aufgabe zu erfüllen, der
 Standard beschreibt zwei Mechanismen: CSMA-CA und ALOHA.
\end_layout

\begin_layout Standard
ALOHA ist ein Anfang der 1970er-Jahre an der Universität von Hawaii entwickeltes
 Protokoll zur Datenübertragung auf geteilten Medien, welches zuerst von
 
\noun on
Abramson
\noun default
 in 
\begin_inset CommandInset citation
LatexCommand cite
key "Abramson:1970:ASA:1478462.1478502"

\end_inset

 beschrieben wurde.
 Es sieht vor, dass ein Knoten Knoten nicht auf das Freiwerden des Mediums
 wartet, sondern seine Nachricht sofort sendet.
 Sollte es dabei zu einer Kollision kommen, weil schon ein anderer Teilnehmer
 sendet, wird das vom Empfänger erkannt und eine Neuübertragung angefordert.
 Alternativ lassen sich auch feste Zeitslots festlegen, in denen ein Knoten
 eine Nachricht sendet, welche allerdings auch nicht unbedingt einem Knoten
 alleine gehören, sondern auch von anderen Knoten genutzt werden können,
 wodurch sich aber Pakete höchstens vollständig überlagern können und andere
 Slots davon nicht beeinflusst werden (vgl.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Roberts:1975:APS:1024916.1024920"

\end_inset

).
 Das ist ausreichend für Netzwerke, in denen nur selten Daten übertragen
 werden, aber ungeeignet für diesen Anwendungsfall, da im Laufe der Zeit
 sehr viele Nachrichten übertragen werden, weshalb es zu sehr vielen Neuübertrag
ungen kommen würde.
\end_layout

\begin_layout Standard
Daher sei nun alternativ der Paketversand unter Verwendung von CSMA-CA (
\emph on
Carrier Sense Medium Access-Colision Avoidance
\emph default
) vorgestellt.
\end_layout

\begin_layout Standard
Wie bereits in Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:PHY-Layer"

\end_inset

 beschrieben, existiert die Möglichkeit zu entscheiden, ob das Medium derzeit
 frei ist oder Daten von einem anderen Knoten derzeit gesendet werden über
 das clear channel assessment (CCA).
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "mathescape=true"
inline false
status open

\begin_layout Plain Layout

func unslottedCSMA():
\end_layout

\begin_layout Plain Layout

	NB = 0, BE = macMinBE
\end_layout

\begin_layout Plain Layout

	bool channel_idle = false
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	while (!channel_idle):
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		wait random($2^{BE} - 1$) * backoffPeriod
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

		channel_idle = perform_cca()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		if (!channel_idle):
\end_layout

\begin_layout Plain Layout

			NB = NB + 1
\end_layout

\begin_layout Plain Layout

			BE = min(BE+1, macMaxBE)
\end_layout

\begin_layout Plain Layout

			if (NB > macMaxCSMABackoffs?):
\end_layout

\begin_layout Plain Layout

				return false
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	return true
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Pseudocode-des-CSMA-CA-Algorithm"

\end_inset

Pseudocode des CSMA-CA-Algorithmus nach Abbildung 11 in 
\begin_inset CommandInset citation
LatexCommand cite
key "802.15.4"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Da die Implementierung des Gossiping-Algorithmus keinen PAN-Knoten verwendet,
 wird hier ausschließlich der unslotted CSMA-CA-Algorithmus beschrieben,
 der als Pseudocode in Algorithmus 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Pseudocode-des-CSMA-CA-Algorithm"

\end_inset

 formuliert wurde.
\end_layout

\begin_layout Standard
Zunächst wird ein zufälliges Intervall gewartet, das durch 
\begin_inset Formula $\text{random}\left(2^{BE}-1\right)\cdot\mathtt{backoffPeriod}$
\end_inset

 bestimmt wird.
 Die 
\begin_inset Formula $\mathtt{backoffPeriod}$
\end_inset

 ist dabei das Produkt aus 
\begin_inset Formula $\mathtt{aUnitBackoffPeriod}$
\end_inset

, also der Anzahl der Symbole (kleinste übertragene Dateneinheit), die gewartet
 wird, und der Übertragungsdauer eines Symbols, die im verwendeten 
\begin_inset Formula $2.45\,GHz$
\end_inset

-Band bei 
\begin_inset Formula $16\mu s$
\end_inset

 liegt.
\end_layout

\begin_layout Standard
Anschließend wird durch das 
\emph on
clear channel assessment
\emph default
 überprüft, ob der Kanal frei ist.
\end_layout

\begin_layout Standard
Ist dies der Fall, wird der Paketversand erlaubt, ansonsten wird der Vorgang
 
\begin_inset Formula $\mathtt{macMaxCSMABackoffs}-1$
\end_inset

-mal wiederholt.
 Dieser Wert kann zwischen 
\begin_inset Formula $0$
\end_inset

 und 
\begin_inset Formula $5$
\end_inset

 sein, als Standardwert ist 
\begin_inset Formula $4$
\end_inset

 angegeben.
\end_layout

\begin_layout Standard
Dabei wird der Backoff Exponent 
\begin_inset Formula $BE$
\end_inset

 inkrementiert, solange er höchstens so groß ist wie 
\begin_inset Formula $\mathtt{macMaxBE}$
\end_inset

(standardmäßig 5).
\end_layout

\begin_layout Standard
Wird bei keiner Wiederholung ein freier Kanal vorgefunden, so wird der Sendevorg
ang abgebrochen.
\end_layout

\begin_layout Standard
Durch das garantierte Warten einer bestimmten Zeit beim Versand eines Pakets
 wird die Datenrate des Mediums reduziert.
 Für die Kalibrierung unseres Gossiping-Algorithmus ist dieses Warten auch
 nicht uninteressant, wenn wir das Intervall festlegen wollen, in denen
 der aktive Thread Nachrichten verschickt.
 So wird schon beim ersten Sendeversuch mit den Standardwert im schlimmsten
 Fall
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
16\mu s\cdot aUnitBackoffPeriod\cdot\left(2^{BE}-1\right) & = & 16\mu s\cdot20\cdot7\\
 & = & 2240\mu s
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
gewartet.
\end_layout

\begin_layout Paragraph
Anmerkung
\end_layout

\begin_layout Standard
Im ursprünglichen Standarddokument 
\begin_inset CommandInset citation
LatexCommand cite
key "802.15.4"

\end_inset

 wurde statt 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

BE = min(BE+1, macMaxBE)
\end_layout

\end_inset

 die Zuweisung
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

BE = min(BE+1, macMinBE)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
angegeben.
 Dieser Fehler wurde in einem Amendment vom 16.
 April 2012 (
\begin_inset CommandInset citation
LatexCommand cite
key "802.15.4-2012"

\end_inset

) behoben.
\end_layout

\end_body
\end_document
