#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 503
\begin_document
\begin_header
\origin unavailable
\textclass scrartcl
\begin_preamble
\usepackage{minted}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language ngerman
\language_package default
\inputencoding utf8
\fontencoding default
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "cmtt" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation 0bp
\quotes_language german
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Section
Grundlagen und Nomenklatur
\end_layout

\begin_layout Standard
In diesem Kapitel werden notwendige Definitionen vorgestellt, die im Folgenden
 zur Beschreibung des Gossiping-Algorithmus und zur Diskussion der Implementieru
ng verwendet werden.
\end_layout

\begin_layout Standard
Dazu wird zunächst die mathematische Darstellung eines verteilten Systems
 beschrieben, wie sie im Rahmen dieser Arbeit angenommen wird, und im Anschluss
 die Kommunikationsmechanismen der Knoten vorgestellt.
\end_layout

\begin_layout Subsection
Beschreibung eines drahtlosen Sensornetzwerks
\end_layout

\begin_layout Standard
Verteilte Systeme lassen sich durch ungerichtete Graphen der Form 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

 beschreiben.
 Dabei sei die Knotenmenge 
\begin_inset Formula $V$
\end_inset

 die Menge aller Sensoren sowie 
\begin_inset Formula $E\subseteq V\times V$
\end_inset

 die Menge aller Kanäle zwischen den Knoten.
\end_layout

\begin_layout Standard
Ein Kanal 
\begin_inset Formula $\{u,v\}\in E$
\end_inset

 mit 
\begin_inset Formula $u,v\in V$
\end_inset

 beschreibt dabei eine bidirektionale Nachbarschaftsrelation zwischen zwei
 Knoten.
 Dies bedeutet, dass sowohl der Knoten 
\begin_inset Formula $u$
\end_inset

 den Knoten 
\begin_inset Formula $v$
\end_inset

 als auch analog der Knoten 
\begin_inset Formula $v$
\end_inset

 den Knoten 
\begin_inset Formula $u$
\end_inset

 kennt und diesem Nachrichten schicken kann.
\end_layout

\begin_layout Standard
Die Nachbarschaft 
\begin_inset Formula $N\left(v\right)$
\end_inset

 eines Knoten 
\begin_inset Formula $v$
\end_inset

 sei die Menge aller Knoten, die vom Knoten 
\begin_inset Formula $v$
\end_inset

 via eines Kanals direkt erreichbar sind:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
\mathcal{N}\left(v\right) & : & V\rightarrow\mathcal{P}\left(E\right)\nonumber \\
\mathcal{N}\left(v\right) & = & \left\{ \begin{array}{c|c}
u\in V & \left\{ v,u\right\} \in E\end{array}\right\} \label{eq:neighbourhood-definition}
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Methoden-zur-Kommunikation"

\end_inset

Methoden zur Kommunikation zwischen Knoten
\end_layout

\begin_layout Standard
Nach der Konstruktion des Netzwerks können die Knoten nun entsprechend Daten
 austauschen.
\end_layout

\begin_layout Standard
In den folgenden theoretischen Betrachtungen werden dafür die Operationen
 
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

send
\end_layout

\end_inset

 und 
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

receive
\end_layout

\end_inset

 verwendet.
\end_layout

\begin_layout Standard
Ein Knoten 
\begin_inset Formula $v$
\end_inset

 kann nur eine Nachricht an einen Nachbarn 
\begin_inset Formula $p$
\end_inset

 aus 
\begin_inset Formula $N\left(v\right)$
\end_inset

 schicken.
 Die 
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

send
\end_layout

\end_inset

-Operation sei dabei asynchron, das heißt der Absender wird nicht blockiert
 bis der Empfänger die Nachricht erhalten hat und kann sofort weiteren Code
 ausführen.
 Eine solche 
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

send
\end_layout

\end_inset

-Operation einer Nachricht 
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

m
\end_layout

\end_inset

 an einen Nachbarn 
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 wird durch die folgende Syntax in den theoretischen Betrachtungen dargestellt:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

send m to p
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Damit der Empfänger eine Nachricht erhalten kann, muss er dies explizit
 durch Verwendung der 
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

receive
\end_layout

\end_inset

-Operation ankündigen.
\end_layout

\begin_layout Standard
Eine Empfangsoperation ist blockierend, das heißt der empfangende Knoten
 kann in dieser Zeit keine anderen Befehle ausführen und wartet so lange
 bis eine Nachricht eintrifft.
\end_layout

\begin_layout Standard
Im Pseudocode wird im Folgenden der Nachrichtenempfang in einen Puffer 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b
\end_layout

\end_inset

 wie folgt dargestellt:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

receive b
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Um herauszufinden, wer der Absender der empfangenen Nachricht ist, wird
 die Funktion 
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

sender(b)
\end_layout

\end_inset

 auf den Puffer angewandt.
\end_layout

\begin_layout Standard
Für die Gossiping-Anwendung wird es nützlich sein, ein Konstrukt zur Verfügung
 zu haben, mit dem man lediglich Nachrichten von einem bestimmten Nachbarn
 empfangen kann, weshalb das folgende Konstrukt hier kurz vorgestellt sei:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

receive b from p
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Dieser Aufruf blockiert den aufrufenden Knoten so lange, bis eine Nachricht
 von dem angegebenen Knoten 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 empfangen wurde.
 Andere Nachrichten von anderen Knoten werden in diesem Falle verworfen.
\end_layout

\begin_layout Standard
Dadurch wird die Semantik der eigentlichen Operationen nicht verfälscht,
 da es sich dabei nur um eine syntaktische Ergänzung handelt.
 Das Verhalten ließe sich leicht mittels einer Schleife und der 
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

sender()
\end_layout

\end_inset

-Funktion auch durch die oben beschriebenen 
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

receive
\end_layout

\end_inset

 Aufrufe darstellen.
\end_layout

\begin_layout Section
Der Gossiping-Algorithmus
\end_layout

\begin_layout Standard
In diesem Kapitel wird nun zunächst die Grundidee des Gossiping-Algorithmus
 vorgestellt und dann konkrete Umsetzungen dieses Verfahrens dargestellt.
 Hauptsächlich werden dabei allgemeine Charakteristika von Gossiping-Algorithmen
 vorgestellt und Aspekte beleuchtet, die für die Nachrichtenverteilzeit
 von Relevanz sind.
 Somit ist vor allem von Interesse, wann die Information im gesamten Netzwerk
 verteilt ist bzw.
 wann der Gossiping-Algorithmus terminiert.
\end_layout

\begin_layout Subsection
Die Grundidee
\end_layout

\begin_layout Standard
Die Grundidee dieses Algorithmus ist schon durch den Namen gegeben: Informatione
n werden 
\begin_inset Quotes gld
\end_inset

tratschend
\begin_inset Quotes grd
\end_inset

 (dt.
 für to gossip) verbreitet.
\end_layout

\begin_layout Standard
Als Beispiel diene die folgende Geschichte: In einem Büro mit einer festen
 Anzahl von Mitarbeitern erhält ein Mitarbeiter die Nachricht, dass zum
 Ende des Jahres einige Arbeitnehmer gekündigt werden.
 Dies ist natürlich eine Nachricht von solcher Prägnanz, dass er diese sofort
 einem Kollegen mitteilt, der ihm im Büro gegenübersitzt.
 Somit ist auch dieser Kollege im Besitz dieser Information, die er dann
 wieder weiter an weitere Kollegen verbreitet.
 Somit verbreitet sich die Nachricht schnell mit beschränktem Aufwand pro
 Mitarbeiter im ganzen Netzwerk, obwohl der erste Mitarbeiter nicht einmal
 alle anderen Mitarbeiter kennen musste.
\end_layout

\begin_layout Standard
Im Kontext der verteilten Systeme seien die Mitarbeiter nun Knoten und die
 möglichen Kollegen, mit denen ein Mitarbeiter kommunizieren kann, seien
 durch die Kanäle zwischen den Knoten gegeben, also durch die Nachbarschaftsrela
tion 
\begin_inset Formula $\mathcal{N}\left(v\right)$
\end_inset

.
\end_layout

\begin_layout Standard
Erhält ein Knoten neue Informationen, sei es durch äußere Einwirkungen oder
 durch Beendigung einer Berechnung, so wird er diese an eine zufällige Teilmenge
 seiner Nachbarn verteilen, welche ebenfalls wieder jeweils eine Teilmenge
 von eigenen Nachbarn auswählen und mit diesen einen Gossip durchführen.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Anforderungen-Gossiping"

\end_inset

Anforderungen an einen Gossiping-Algorithmus
\end_layout

\begin_layout Standard
Im Folgenden wird ein Algorithmus als Gossiping-Algorithmus bezeichnet,
 wenn er die Anforderungen erfüllt, die von 
\noun on
Birman
\noun default
 in 
\begin_inset CommandInset citation
LatexCommand cite
key "Birman:2007:PLG:1317379.1317382"

\end_inset

 vorgeschlagen wurden.
\end_layout

\begin_layout Enumerate
Kern des Protokolls sind periodische und paarweise Interaktionen zwischen
 verschiedenen Prozessen.
\end_layout

\begin_layout Enumerate
Die Information, die durch in Punkt 1 beschriebene Interaktionen versendet
 wird, ist von beschränkter Größe.
\end_layout

\begin_layout Enumerate
Wenn zwei Prozesse interagieren, ändert sich der Zustand eines oder beider
 Prozesse insofern, dass es den Status des anderen reflektiert.
\end_layout

\begin_layout Enumerate
Eine verlässliche Kommunikation wird nicht vorausgesetzt.
\end_layout

\begin_layout Enumerate
Die Interaktionsfrequenz ist im Vergleich zu den Latenzen des Nachrichtenaustaus
chs gering.
\end_layout

\begin_layout Enumerate
Die Auswahl des Nachbarknotens, mit dem interagiert wird, geschieht auf
 irgendeine Art und Weise zufällig.
\end_layout

\begin_layout Paragraph
Zu 1.
\end_layout

\begin_layout Standard
Dieser Punkt besagt vor allem, dass ein Prozess nach einer Interaktion mit
 einem anderen Prozess eine gewisse Zeit wartet, bis er erneut Daten sendet.
 Diese Periodendauer ist gleich für alle Prozesse.
 Jede Interaktion findet dabei nur mit einem weiteren Prozess statt.
\end_layout

\begin_layout Paragraph
Zu 2.
\end_layout

\begin_layout Standard
Jede Nachricht, die zwischen Knoten ausgetauscht wird, lässt sich durch
 eine globale obere Schranke in ihrer Größe beschränken.
 Das bedeutet, dass Gossiping vor allem dafür gedacht ist, kleinere Datenmengen
 in einem Netzwerk zu verteilen.
\end_layout

\begin_layout Paragraph
Zu 3.
\end_layout

\begin_layout Standard
Wenn also ein Prozess eine Nachricht von einem anderen Prozess erhält, so
 muss der Inhalt dieser Nachricht die Entscheidung den eigenen Zustand zu
 ändern motivieren.
 Ein Beispiel für einen Verstoß gegen diese Regel wäre, wenn der Prozess
 diese Nachricht nur dazu nutzen würde, um die Zeit zu berechnen, die benötigt
 wird, um eine Nachricht zwischen den beiden Knoten hin und her zu tauschen.
\end_layout

\begin_layout Paragraph
Zu 4.
\end_layout

\begin_layout Standard
Dieser Punkt ist einer der großen Stärken von Gossiping-Algorithmen in drahtlose
n Sensornetzwerken, in denen Knoten wegen äußerer Einwirkungen nicht immer
 unbedingt verfügbar sind oder Nachrichten während der Kommunikation beschädigt
 werden können.
 Das bedeutet, dass der Verlust oder das Ausbleiben einer Nachricht an einen
 Knoten nicht die weitere Ausführung des Algorithmus verhindert.
\end_layout

\begin_layout Paragraph
Zu 5.
\end_layout

\begin_layout Standard
Dieser Punkt steht in direktem Zusammenhang mit dem ersten Punkt.
 Die periodischen Interaktionen ermöglichen es, den Ablauf des Gossiping-Algorit
hmus in Runden einzuteilen und somit den Ablauf des Algorithmus klar rekonstruie
ren zu können.
 Wäre jetzt die Zeit zwischen den Interaktionen kleiner als die maximale
 Dauer des Nachrichtenaustausches, so würde ein Knoten bereits eine neue
 Interaktion initiieren, bevor die vorherige überhaupt abgeschlossen ist
 und er seinen Zustand entsprechend anpassen konnte.
\end_layout

\begin_layout Paragraph
Zu 6.
\end_layout

\begin_layout Standard

\noun on
Birman
\noun default
 stellt hier eine weniger strikte Anforderung, da für ihn kein Nachbarknoten
 ausgewählt werden muss.
 Durch die Konstruktion eines entsprechenden Overlays, das alle erreichbaren
 Knoten eines Knotens zu einem Nachbarknoten macht, zeigt aber, dass die
 Definition dadurch nicht eingeschränkt wurde.
 Da in den drahtlosen Sensornetzwerken aber vor allem die Nachbarn als Kommunika
tionspartner in Frage kommen, wurde das Kriterium entsprechend angepasst.
\end_layout

\begin_layout Standard
Dieses Zufallskriterium spielt auch stark mit der vierten Anforderung zusammen,
 da der Algorithmus dadurch nicht abhängig davon ist, diesen nicht erreichbaren
 Knoten zu kontaktieren, anders als bei einem deterministischen Algorithmus,
 der zu jedem Zeitpunkt einen klar definierten Nachbarn zurückgibt.
\end_layout

\begin_layout Subsection
Gossiping als epidemischer Algorithmus
\end_layout

\begin_layout Standard
Der Gossiping-Algorithmus, oftmals auch als Rumor Spreading-Algorithmus
 bezeichnet, wird der Klasse der epidemischen Algorithmen zugeordnet.
 Die Idee der epidemischen Algorithmen, die von 
\noun on
Demers
\noun default
 et al.
 in 
\begin_inset CommandInset citation
LatexCommand cite
key "Demers:1987:EAR:41840.41841"

\end_inset

 vorgestellt wurde, beruht auf den mathematischen Modellen der epidemischen
 Verbreitung von Viren und anderer Krankheitserreger, die von Virologen
 verwendet wird, um die Verbreitung von Krankheitserregern vorauszusagen.
\end_layout

\begin_layout Standard
Während aber der Virologe gemeinhin versucht, die Verbreitung des Virus
 möglichst einzudämmen, so ist für den Entwurf von epidemischen Algorithmen
 hingegen in der Regel ein Verlauf gewünscht, der eine möglichst schnelle
 Verbreitung der Informationen gewährleistet.
\end_layout

\begin_layout Subsubsection
Knotenzustände
\end_layout

\begin_layout Standard
\begin_inset CommandInset citation
LatexCommand cite
key "Demers:1987:EAR:41840.41841"

\end_inset

 ordnet einem Knoten 
\begin_inset Formula $v\in V$
\end_inset

 einen von drei Zuständen zu.
 Diese sind der in der Epidemologie entlehnt und werden in den folgenden
 Betrachtungen zur Charakterisierung des Verhaltens eines Knotens verwendet:
\end_layout

\begin_layout Description
infiziert
\begin_inset space \space{}
\end_inset

(infected) Der Knoten besitzt eine Information, die er an andere Knoten
 weitergeben kann und will, und wird dies von nun an versuchen.
\end_layout

\begin_layout Description
empfänglich
\begin_inset space \space{}
\end_inset

(susceptible) Der Knoten besitzt noch keine neuen Informationen, er ist
 also für die Information anderer Knoten empfänglich.
\end_layout

\begin_layout Description
entfernt(removed) Der Knoten hat die neuen Informationen erhalten, will
 diese aber nicht mehr weiter verbreiten.
\end_layout

\begin_layout Standard
Im Folgenden sei 
\begin_inset Formula $I$
\end_inset

 die Menge der infizierten Knoten in 
\begin_inset Formula $V$
\end_inset

, 
\begin_inset Formula $S$
\end_inset

 die Menge der empfänglichen Knoten und 
\begin_inset Formula $R$
\end_inset

 die Menge der entfernten Knoten:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
I & = & \left\{ \begin{array}{c|c}
v\in V & v\text{ ist infiziert}\end{array}\right\} \\
S & = & \left\{ \begin{array}{c|c}
v\in V & v\text{ ist empfänglich}\end{array}\right\} \\
R & = & \left\{ \begin{array}{c|c}
v\in V & v\text{ ist entfernt}\end{array}\right\} 
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Da jeder Knoten höchstens einen Zustand haben darf, gilt:
\begin_inset Formula 
\begin{eqnarray}
I\cap S\cap R & = & \emptyset\label{eq:subsetcut}
\end{eqnarray}

\end_inset

Jeder Knoten muss aber auch einen dieser drei Zustände haben, so dass 
\begin_inset Formula 
\begin{eqnarray}
I\cup S\cup R & = & V\label{eq:subsetconjunct}
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Modellierung-von-Gossiping"

\end_inset

Modellierung von Gossiping als epidemischer Algorithmus
\end_layout

\begin_layout Standard
Zunächst wird das Rumor Spreading als epidemischer Algorithmus beschrieben,
 welches nach 
\begin_inset CommandInset citation
LatexCommand cite
key "Demers:1987:EAR:41840.41841"

\end_inset

 zunächst von einem oder sehr wenigen infizierten Knoten ausgeht.
\end_layout

\begin_layout Standard
Ein Knoten 
\begin_inset Formula $v\in I$
\end_inset

, d.h.
 ein Knoten im Zustand 
\emph on
infiziert
\emph default
, wählt in periodischen Abständen einen Knoten aus 
\begin_inset Formula $\mathcal{N}\left(v\right)$
\end_inset

 aus und schickt ihm seine neuen Informationen.
 Der Empfänger antwortet mit seinen bisherigen Informationen.
\end_layout

\begin_layout Standard
Kannte der Empfänger die Informationen bereits, so hört der Knoten 
\begin_inset Formula $v$
\end_inset

 mit Wahrscheinlichkeit 
\begin_inset Formula $\frac{1}{k}$
\end_inset

 auf, Informationen auszutauschen und geht in den Zustand 
\emph on
entfernt
\emph default
 über.
\end_layout

\begin_layout Standard
Ein empfänglicher Knoten, der Informationen erhält, geht in den Zustand
 
\emph on
infiziert
\emph default
 über und beginnt nun ebenfalls einen zufälligen Nachbarn auszuwählen und
 diesem die eigene Information mitzuteilen.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /Users/davidbohn/Bachelor-Thesis/images/3-2-infection-states.pdf
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Zustandsübergänge beim Gossiping beschrieben als epidemischen Vorgang (eigene
 Abbildung)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Analyse-von-diesem"

\end_inset

Analyse von diesem Gossiping-Modell
\end_layout

\begin_layout Standard
Das lässt nun die Frage aufkommen, wann das System in einen Zustand kommt,
 in dem keine weiteren Nachrichten ausgetauscht werden.
\end_layout

\begin_layout Standard
Es gelte zunächst die Annahme, dass die Kanäle zwischen den Knoten verlustfrei
 und die Sende- und Empfangsoperationen atomar sind.
 Dies sind gerade in drahtlosen Sensornetzen sehr starke Einschränkungen,
 die aber zu der Zeit und für den Anwendungszweck von 
\noun on
Demers 
\noun default
et al.
 hinnehmbar waren.
\end_layout

\begin_layout Standard
Dazu wird die Änderung der Anteile der 
\emph on
infizierten
\emph default
, 
\emph on
empfänglichen
\emph default
 und 
\emph on
entfernten
\emph default
 Knoten an der gesamten Knotenmenge 
\begin_inset Formula $V$
\end_inset

 über die Zeit betrachtet.
 Sei 
\begin_inset Formula $i=\frac{\left|I\right|}{\left|V\right|}$
\end_inset

 der Anteil der infizierten Knoten, 
\begin_inset Formula $s=\frac{\left|S\right|}{\left|V\right|}$
\end_inset

 der Anteil der empfänglichen Knoten sowie 
\begin_inset Formula $r=\frac{\left|R\right|}{\left|V\right|}$
\end_inset

 der Anteil der entfernten Knoten.
 Aus 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:subsetcut"

\end_inset

 und 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:subsetconjunct"

\end_inset

 folgt daher:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
i+r+s & = & 1\label{eq:epidemic-fractionsum}
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
Nach 
\begin_inset CommandInset citation
LatexCommand cite
key "Demers:1987:EAR:41840.41841"

\end_inset

 lässt sich die Verbreitung der Information nun über zwei Differentialgleichunge
n beschreiben:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
\frac{ds}{dt} & = & -s\cdot i\label{eq:susceptible-change}\\
\frac{di}{dt} & = & s\cdot i-\frac{1}{k}\left(1-s\right)\cdot i\label{eq:infected-change}
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
Gleichung 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:susceptible-change"

\end_inset

 beschreibt dabei die Änderung des Anteils der empfänglichen Knoten an 
\begin_inset Formula $V$
\end_inset

 pro Zeiteinheit.
 Das Produkt beschreibt den Anteil der empfänglichen Knoten, die von den
 infizierten Knoten ausgewählt werden und die neue Information erhalten.
 Dadurch verlassen sie den Zustand 
\emph on
empfänglich
\emph default
, weshalb diese Menge in jedem Zeitschritt kleiner wird.
\end_layout

\begin_layout Standard
Analog befindet sich ein entgegengesetzte Term in Gleichung 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:infected-change"

\end_inset

, da diese Knoten ja nun 
\emph on
infiziert
\emph default
 sind und diese Menge dadurch größer wird.
 Zusätzlich gibt es aber noch den Fall, dass ein infizierter Knoten einen
 Knoten kontaktiert hat, der die Information bereits kennt.
 Wie oben beschrieben hört dieser dann mit Wahrscheinlichkeit 
\begin_inset Formula $\frac{1}{k}$
\end_inset

 auf, die Nachricht zu verteilen und ist dann nicht mehr 
\emph on
infiziert
\emph default
, sondern geht in den Zustand 
\emph on
entfernt
\emph default
 über.
 Der Anteil der Knoten, die nicht empfänglich sind, d.h.
 bei denen diese Entscheidung stattfindet, ist durch 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:epidemic-fractionsum"

\end_inset

 als 
\begin_inset Formula $1-s$
\end_inset

 gegeben.
\end_layout

\begin_layout Standard
Wir wollen nun geeignete Werte für 
\begin_inset Formula $k$
\end_inset

 finden, die eine möglichst zuverlässige Verteilung der Daten im Netz sicherstel
lt.
 Zur Lösung wird dazu in 
\begin_inset CommandInset citation
LatexCommand cite
key "Demers:1987:EAR:41840.41841"

\end_inset

 das Verhältnis 
\begin_inset Formula $\frac{di}{ds}$
\end_inset

 gebildet.
 Dadurch entfernen wir die zeitliche Komponente und erhalten:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\frac{di}{ds} & = & -\frac{s\cdot i-\frac{1}{k}\left(1-s\right)\cdot i}{s\cdot i}\\
 & = & -1+\frac{\left(1-s\right)\cdot i}{k\cdot s\cdot i}\\
 & = & -1+\frac{i-s\cdot i}{k\cdot s\cdot i}\\
 & = & -1+\frac{\cancel{i}}{k\cdot s\cdot\cancel{i}}-\frac{\cancel{s\cdot i}}{k\cdot\cancel{s\cdot i}}\\
 & = & -\frac{k+1}{k}+\frac{1}{k\cdot s}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Durch Integration entsteht nun eine Funktion 
\begin_inset Formula $i\left(s\right)$
\end_inset

, die zu einem Anteil an empfänglichen Knoten einen entsprechenden Anteil
 an infizierten Knoten bestimmt:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
i\left(s\right) & = & -\frac{k+1}{k}s+\frac{1}{k}\ln s+c\label{eq:i-nach-integration}
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
Für große Knotenmengen 
\begin_inset Formula $V$
\end_inset

 konvergiert 
\begin_inset Formula $c$
\end_inset

 gegen den folgenden Wert (
\begin_inset CommandInset citation
LatexCommand cite
key "Demers:1987:EAR:41840.41841"

\end_inset

):
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
c & = & \frac{k+1}{k}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Durch Einsetzen in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:i-nach-integration"

\end_inset

 ergibt sich die Funktion:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
i\left(s\right) & = & \frac{k+1}{k}\left(1-s\right)+\frac{1}{k}\ln s\label{eq:i-depend-on-s}
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
Zur Bestimmung der Anzahl der empfänglichen Knoten, bei denen es keine infiziert
en Knoten mehr gibt, also das System inaktiv geworden ist, wird diese Funktion
 null gesetzt.
 Dadurch entsteht die folgende implizite Gleichung für die Anzahl der empfänglic
hen Knoten:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
s & = & e^{-\left(k+1\right)\left(1-s\right)}\label{eq:development-of-s}
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
Aus dieser Gleichung wird ersichtlich, dass 
\begin_inset Formula $s$
\end_inset

 lediglich von 
\begin_inset Formula $k$
\end_inset

 und sich selbst abhängt:
\end_layout

\begin_layout Standard
In Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Anteil-empfänglicher-Knoten"

\end_inset

 ist das Verhalten der Gleichung bei sich änderndem 
\begin_inset Formula $k$
\end_inset

 dargestellt.
 Der erste Term des Exponenten 
\begin_inset Formula $k+1$
\end_inset

 ist der dominante Term, weshalb dieser den Kurvenverlauf maßgeblich vorgibt.
 Der zweite Term (
\begin_inset Formula $1-s$
\end_inset

) ist stets im Intervall 
\begin_inset Formula $\left[0,1\right]$
\end_inset

 und wird somit schnell vom Term 
\begin_inset Formula $k+1$
\end_inset

 verdrängt, weshalb die Abbildung einen guten Ansatzpunkt liefert.
\end_layout

\begin_layout Standard
Wird somit zum Beispiel 
\begin_inset Formula $k=1$
\end_inset

 gewählt, d.h.
 ein infizierter Knoten geht sofort in den Zustand entfernt über, sobald
 er einen nicht empfänglichen Knoten kontaktiert, so sind am Ende noch ca.
 
\begin_inset Formula $20\%$
\end_inset

 der Knoten empfänglich, haben also die Information nicht bekommen und können
 sie auch nicht mehr erhalten.
 Wird 
\begin_inset Formula $k$
\end_inset

 aber auf 
\begin_inset Formula $2$
\end_inset

 erhöht, d.h.
 ein infizierter Knoten geht mit 
\begin_inset Formula $50\%$
\end_inset

iger Wahrscheinlichkeit in den Zustand 
\emph on
entfernt
\emph default
 über, so schrumpft der Anteil der Knoten, die die Information nicht erhalten,
 auf lediglich 
\begin_inset Formula $6\%$
\end_inset

 (vgl.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Demers:1987:EAR:41840.41841"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways true
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/davidbohn/Bachelor-Thesis/images/3-2-decay.pdf
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Anteil-empfänglicher-Knoten"

\end_inset

Anteil empfänglicher Knoten nach Entfernung des letzten Infizierten über
 
\begin_inset Formula $k$
\end_inset

 (eigene Abbildung)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Anti-Entropie
\end_layout

\begin_layout Standard
Ein beinahe noch einfacherer Ansatz ist die Anti-Entropie, die ebenfalls
 in 
\begin_inset CommandInset citation
LatexCommand cite
key "Demers:1987:EAR:41840.41841"

\end_inset

 vorgestellt wird.
 Die Idee hierbei ist, dass die Knoten in periodischen Abständen untereinander
 einen Abgleich der Daten durchführen.
 Somit entfällt das Entfernen der Knoten mit Wahrscheinlichkeit 
\begin_inset Formula $\frac{1}{k}$
\end_inset

, wenn der kontaktierte Partner bereits die Daten kannte.
\end_layout

\begin_layout Standard
In jeder Periode wählt ein Knoten also einen anderen Knoten aus und tauscht
 mit diesem Informationen aus.
 Dabei gibt es drei verschiedene Möglichkeiten: Entweder schickt er lediglich
 seine Daten an seinen ausgewählten Nachbarn (
\emph on
push
\emph default
), fordert die Daten des Nachbarn an (
\emph on
pull
\emph default
) oder schickt seine Daten und erwartet die des Nachbarn (
\emph on
push-pull
\emph default
).
\end_layout

\begin_layout Standard
Ein großer Nachteil im Vergleich zum vorherigen Ansatz ist die hohe Belastung
 des Funkmediums, da jeder Knoten, auch wenn er keine aktuellen Informationen
 kennt, also empfänglich ist, seine Daten regelmäßig über das Netz an einen
 anderen Knoten verteilt.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Push-Pull-PP"

\end_inset

Push, Pull und Push-Pull
\end_layout

\begin_layout Standard
Bereits im vorherigen Abschnitt wurden die verschiedenen Arten des Datenaustausc
hs bei Verwendung eines Anti-Entropie-Algorithmus vorgestellt.
 Diese lassen sich nicht nur auf die Anti-Entropie anwenden, sondern auch
 auf den in Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Modellierung-von-Gossiping"

\end_inset

 und 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Analyse-von-diesem"

\end_inset

 vorgestellten Algorithmus.
 So kann auch ein empfänglicher Knoten z.B.
 mit einer bestimmten Wahrscheinlichkeit einen Nachbarknoten nach seinen
 Informationen fragen und damit einen 
\emph on
pull
\emph default
 durchzuführen.
 Wenn dieser ein infizierter Knoten war, wird er dadurch selbst infiziert
 und fängt damit an Nachrichten per 
\emph on
push
\emph default
 an andere Knoten zu verteilen.
 Neben dieser Mischform ist es auch möglich, eine reine pull-Strategie durchzufü
hren, indem nur die empfänglichen Knoten die infizierten anfragen.
\end_layout

\begin_layout Standard
Interessanterweise weisen push, pull und push-pull unterschiedliche Charakterist
ika auf, die sich vor allem in der Geschwindigkeit der Informationsverbreitung
 widerspiegeln.
\end_layout

\begin_layout Minisec
Push
\end_layout

\begin_layout Standard
Jeder infizierte Knoten leitet in diesem Fall pro Runde seine Information
 an genau einen anderen Knoten, ohne dass dieser diese angefordert hat.
 Initial sind wenige Knoten infiziert (oftmals genau einer) und die Chance,
 einen Knoten zu finden, der die Nachricht noch nicht erhalten hat, ist
 hoch.
 Somit wächst die Menge der Infizierten nach 
\noun on
Karp
\noun default
 et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "892324"

\end_inset

 zunächst exponentiell bis ungefähr die Hälfte (
\begin_inset Formula $\frac{n}{2}$
\end_inset

) der Knoten infiziert ist.
 Anschließend nimmt die Zahl der empfänglichen Knoten um einen konstanten
 Faktor ab.
 In jeder Runde empfangen dann nämlich ungefähr 
\begin_inset Formula $\frac{1}{e}$
\end_inset

 Knoten keine Nachricht.
 Aus diesem Grund werden nach der exponentiellen Phase 
\begin_inset Formula $\Theta\left(\ln n\right)$
\end_inset

 Runden benötigt bis alle Knoten die Nachricht empfangen haben.
 
\noun on
Pittel
\noun default
 ermittelte in 
\begin_inset CommandInset citation
LatexCommand cite
key "10.2307/2101696"

\end_inset

 sogar eine Anzahl von 
\begin_inset Formula $\log_{2}\left(n\right)+\ln\left(n\right)+O\left(1\right)$
\end_inset

 Runden bis alle Knoten die Nachricht erhalten haben.
\end_layout

\begin_layout Minisec
Pull
\end_layout

\begin_layout Standard
In diesem Fall ist die initiale Verbreitung der Information deutlich langsamer,
 da in den ersten Runden der infizierte Knoten bzw.
 die infizierten Knoten nicht unbedingt kontaktiert wurden.
 Nach 
\begin_inset CommandInset citation
LatexCommand cite
key "892324"

\end_inset

 sind nach 
\begin_inset Formula $O\left(\ln n\right)$
\end_inset

 Runden mit hoher Wahrscheinlichkeit 
\begin_inset Formula $\frac{n}{2}$
\end_inset

 Knoten infiziert.
 Aber ab diesem Punkt verbessert sich die Verteilung der Nachricht deutlich
 im Vergleich zum Push-Algorithmus, der ab diesem Punkt nur noch höchstens
 konstant viele Knoten neu infiziert.
 Seien zu Beginn der Runde 
\begin_inset Formula $s\cdot n$
\end_inset

 Knoten empfänglich, wobei 
\begin_inset Formula $s$
\end_inset

 wie oben der Anteil der empfänglichen Knoten sei, dann gilt für jeden empfängli
chen Knoten, dass er in dieser Runde mit Wahrscheinlichkeit 
\begin_inset Formula $1-s$
\end_inset

 infiziert wird.
 Daraus ergibt sich ein Erwartungswert von 
\begin_inset Formula $s^{2}n$
\end_inset

 empfängliche Knoten nach Ende der Runde.
 Also werden nach der Infektion der halben Population nur noch 
\begin_inset Formula $\Theta\left(\ln\ln n\right)$
\end_inset

 Runden benötigt, um alle Knoten zu infizieren.
 Insgesamt werden also 
\begin_inset Formula $O\left(\ln n\right)+\Theta\left(\ln\ln n\right)$
\end_inset

 Runden benötigt, um alle Knoten zu infizieren.
\end_layout

\begin_layout Minisec
Push-Pull
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /Users/davidbohn/Bachelor-Thesis/images/gossip-round.pdf
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Eine Gossiping Runde zwischen einem infizierten Knoten (A) und einen empfänglich
en Knoten (B) bei Push-Pull (eigene Abbildung)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Während der Datenaustausch per 
\emph on
push
\emph default
 für bis zu 
\begin_inset Formula $\frac{n}{2}$
\end_inset

 infizierten Knoten deutlich schneller funktioniert als pull, funktioniert
 letzteres deutlich besser ab diesem Punkt als 
\emph on
push
\emph default
.
 Es liegt also nahe, beide Varianten in ein Verfahren zu kombinieren, um
 somit auch die Stärken zu kombinieren.
 
\begin_inset CommandInset citation
LatexCommand cite
key "892324"

\end_inset

 unterteilt die Dissemination in vier Phasen.
 Zunächst kennt nur ein Knoten die neuen Informationen.
 Die Wahrscheinlichkeit, dass er in 
\begin_inset Formula $c$
\end_inset

 Runden mindestens einen empfänglichen Knoten kontaktiert hat, also nicht
 sich selbst, ist 
\begin_inset Formula $1-n^{-c}$
\end_inset

, weshalb sich mit hoher Wahrscheinlichkeit die Anzahl der Infizierten nach
 
\begin_inset Formula $c$
\end_inset

 Runden verdoppelt hat.
 Somit sind nach 
\begin_inset Formula $O\left(\ln\ln n\right)$
\end_inset

 Runden 
\begin_inset Formula $\left(\ln n\right)^{4}$
\end_inset

 Knoten infiziert.
 Ab diesem Punkt beginnt eine stark exponentielle Verbreitung der Information.
 Diese dauert an bis ungefähr 
\begin_inset Formula $\frac{n}{\ln n}$
\end_inset

 Knoten infiziert sind.
 Dafür werden 
\begin_inset Formula $\log_{3}n\pm O\left(\ln\ln n\right)$
\end_inset

 Runden benötigt.
 Die beiden letzten Phasen beschreiben zunächst eine quadratische Abnahme
 und das Ausklingen durch Infektion der verbliebenen Knoten.
 Beide Phasen benötigen aber lediglich 
\begin_inset Formula $O\left(\ln\ln n\right)$
\end_inset

 Runden.
 Somit erreicht Push-Pull nach 
\begin_inset CommandInset citation
LatexCommand cite
key "892324"

\end_inset

 eine komplette Verteilung der Daten in etwa 
\begin_inset Formula $\log_{3}n+O\left(\ln\ln n\right)$
\end_inset

 Runden.
\end_layout

\begin_layout Subsubsection
Fazit
\end_layout

\begin_layout Standard
Die obigen Betrachtungen zeigen, dass nicht genau bestimmt werden kann,
 nach wie vielen Runden ein Paket im gesamten Netzwerk verteilt wurde.
 So kann es selbst nach vielen Runden noch immer Knoten geben, die die Nachricht
 nicht empfangen haben, obwohl die Wahrscheinlichkeit dafür gering sein
 sollte.
 Es kann in einigen Anwendungen verkraftbar sein, dass dieser Fall eintritt.
 Im Rahmen der Implementierung zur Bestimmung der Nachrichtenverteilzeit
 muss aber auf diese Situationen Rücksicht genommen werden, um das Experiment
 irgendwann abzubrechen.
\end_layout

\begin_layout Standard
Des Weiteren hat dieser Ansatz das Problem, dass er verlässliche Datenkanäle
 annimmt.
 Eine solche Annahme ist aber für drahtlose Sensornetzwerke nicht haltbar,
 weshalb im Folgenden Möglichkeiten vorgestellt werden, wie man mit dieser
 Problematik umgehen kann.
\end_layout

\begin_layout Subsection
Gossiping-Framework
\end_layout

\begin_layout Standard

\noun on
Bakhshi
\noun default
 et al.
 stellten in 
\begin_inset CommandInset citation
LatexCommand cite
key "6042051,5290827"

\end_inset

 ein Framework für Gossiping-Anwendungen vor, das im Folgenden betrachtet
 wird und als Grundlage der Überlegungen zu Gossiping auf nicht verlässlichen
 Kanälen verwendet wird.
 Dieses Framework erlaubt es, jeden Gossiping-Algorithmus durch die Definition
 weniger Funktionen zu beschreiben.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},mathescape=true"
inline false
status open

\begin_layout Plain Layout

wait $
\backslash
Delta t$ time units;
\end_layout

\begin_layout Plain Layout

$p$ = RandomPeer();
\end_layout

\begin_layout Plain Layout

$
\backslash
sigma$ = PrepareMsg();
\end_layout

\begin_layout Plain Layout

send $
\backslash
sigma$ to $p$;
\end_layout

\begin_layout Plain Layout

wait until receive $
\backslash
sigma_p$ from $p$;
\end_layout

\begin_layout Plain Layout

Update($
\backslash
sigma$, $
\backslash
sigma_p$);
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},mathescape=true"
inline false
status open

\begin_layout Plain Layout

wait until receive $
\backslash
sigma_p$;
\end_layout

\begin_layout Plain Layout

$
\backslash
sigma$ = PrepareMsg();
\end_layout

\begin_layout Plain Layout

send $
\backslash
sigma$ to sender($
\backslash
sigma_p$);
\end_layout

\begin_layout Plain Layout

Update($
\backslash
sigma$, $
\backslash
sigma_p$);
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align center
a) aktiver Thread
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align center
b) passiver Thread
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Gossiping-Framework-nach-Bakhshi"

\end_inset

Gossiping-Framework nach 
\noun on
Bakhshi
\noun default
 et al.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Jeder Knoten besitzt einen lokalen Cache, der die Daten des Knotens beinhaltet,
 die durch das Gossiping verbreitet und verändert werden.
 Das Framework sieht vor, dass ein Knoten zwei Threads ausführt - einen
 aktiven und einen passiven Thread.
\end_layout

\begin_layout Standard
Der passive Thread ist dabei dafür zuständig, eine Nachricht von einem Nachbarn
 zu empfangen, mit den eigenen Informationen im entsprechenden Cache-Segment
 zu antworten und den eigenen Cache entsprechend zu aktualisieren.
\end_layout

\begin_layout Standard
Der aktive Thread wird in einem festen Intervall 
\begin_inset Formula $\Delta t$
\end_inset

 ausgeführt.
 Alle Knoten verwenden dabei dasselbe Intervall.
 Alle 
\begin_inset Formula $\Delta t$
\end_inset

 Zeiteinheiten wählt der Knoten einen Nachbarn aus, wählt eine Teilmenge
 des Caches (oder den ganzen) aus, schickt diese an den Knoten und wartet
 auf die Antwort, die von dessen passivem Thread geschickt wird, um anhand
 dieser Antwort den eigenen Cache zu aktualisieren.
\end_layout

\begin_layout Standard
Die Funktionen 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RandomPeer()
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

PrepareMsg()
\end_layout

\end_inset

 und 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Update()
\end_layout

\end_inset

 sind dabei entsprechend davon abhängig, wie der Algorithmus genau funktionieren
 soll, also wofür man den Gossiping-Algorithmus verwenden will.
\end_layout

\begin_layout Standard
Die Funktion 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RandomPeer()
\end_layout

\end_inset

 wählt aus der Menge 
\begin_inset Formula $N\left(v\right)$
\end_inset

 einen Vertreter aus.
 Diese Auswahl muss eine zufällige Komponente beinhalten.
 Eine Auswahl des Caches wird mit der Funktion 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

PrepareMsg()
\end_layout

\end_inset

 generiert.
 In manchen Anwendungen ist der Cache nicht weiter unterteilbar, weil er
 z.B.
 aus nur einem Wert besteht, dann wird immer der gesamte Cache übertragen.
 Andererseits kann durch entsprechende Definition der 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

PrepareMsg()
\end_layout

\end_inset

 Funktion auch eine Pull-Strategie realisiert werden, indem man ein leeres
 Cache-Element verschickt, auf das der passive Thread dann mit seinen Daten
 antwortet.
\end_layout

\begin_layout Standard
Die Aktualisierung des eigenen Caches bei Empfang eines Datenpakets geschieht
 in der 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Update()
\end_layout

\end_inset

-Funktion.
 Über diese Funktion lässt sich an diesem Punkt nicht mehr sagen, als dass
 sie Anforderung Nr.
 3 aus Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Anforderungen-Gossiping"

\end_inset

 erfüllen muss, das heißt sie darf den eigenen Cache nur insofern ändern,
 dass diese Änderung auf Basis des empfangenen Pakets geschieht.
\end_layout

\begin_layout Standard
Die weiteren Anforderungen 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Anforderungen-Gossiping"

\end_inset

 werden bei vorsichtiger Definition der drei eben beschriebenen Funktionen
 ebenfalls durch das Framework erfüllt.
\end_layout

\begin_layout Standard
Der aktive Thread stellt sicher, dass es eine periodische, paarweise Interaktion
 zwischen den Prozessen gibt.
 Solange das von 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

PrepareMsg()
\end_layout

\end_inset

 generierte Paket eine maximale Größe hat, so wird auch die Anforderung
 Nr.
 2 erfüllt, dass der Datenaustausch immer eine maximale Größe hat.
\end_layout

\begin_layout Standard
Auch Anforderung Nr.
 4 wird von diesem Ansatz erfüllt, da davon ausgegangen wird, dass ein Knoten
 sich nicht merkt, mit welchen Nachbarn er bereits interagiert hat oder
 zumindest irgendwann wieder Kontakt mit diesen aufnehmen wird, wenn man
 den Algorithmus nur lange genug laufen lässt.
\end_layout

\begin_layout Standard
Der einzige Haken hierbei ist Zeile 5 des aktiven Threads.
 In dieser wartet ein Prozess so lange, bis er eine Antwort von einem Prozess
 bekommt.
 Hier ein infinites Warten vorauszusetzen ist nicht sinnvoll, sondern sollte
 eher durch einen timeout ergänzt werden, der leicht unter dem Intervall
 
\begin_inset Formula $\Delta t$
\end_inset

 liegt, um somit in der nächsten Runde wieder teilnehmen zu können.
\end_layout

\begin_layout Standard
Durch eine entsprechend große Wahl von 
\begin_inset Formula $\Delta t$
\end_inset

 wird auch Anforderung Nr.
 5 erfüllt, also dass die Frequenz des Austauschs deutlich geringer ist
 als die Latenz der Austauschs.
 Bei der praktischen Umsetzung muss dann dieser Wert entsprechend an die
 Hardware angepasst werden.
\end_layout

\begin_layout Standard
Anforderung Nr.
 6, die zufällige Auswahl der Kommunikationspartner, wird durch die Funktion
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RandomPeer()
\end_layout

\end_inset

 erfüllt, insofern sie der Spezifikation entsprechend implementiert wurde.
\end_layout

\begin_layout Subsubsection
Abgrenzung zur vorherigen Beschreibung und Nutzen
\end_layout

\begin_layout Standard
Dieses Framework schafft es, die anwendungsspezifischen Komponenten des
 Gossiping-Algorithmus in wenige Methoden zu extrahieren.
 Anders als in den bisherigen Erläuterungen zeigt dieser Ansatz erstmalig,
 wie sich beliebige Algorithmen auf Basis von Gossiping umsetzen lassen.
\end_layout

\begin_layout Standard
Dabei formuliert das Framework einen Algorithmus, der eher mit der Anti-Entropie
 zu vergleichen ist, da stets alle Knoten in einer Runde aktiv werden.
 Des Weiteren lassen sich mit diesem auch alle Datenaustausch-Semantiken
 (
\emph on
push
\emph default
, 
\emph on
pull
\emph default
 und 
\emph on
push-pull
\emph default
) zu realisieren.
\end_layout

\begin_layout Standard
Da es sich hierbei um eine generische Formulierung des Gossiping-Algorithmus
 handelt, werden keine konkreten Abbruchkriterien behandelt, das heißt der
 Nachrichtenaustausch wird über die ganze Laufzeit des Systems fortgesetzt.
\end_layout

\begin_layout Subsection
Gossiping über unzuverlässige Kanäle
\end_layout

\begin_layout Standard
Gossiping-Algorithmen über unzuverlässige Kanäle stellen hohe Anforderungen
 an die Analyse, die oftmals auch stark vom implementierten Verfahren abhängen.
 Zur Analyse dieser Gossiping-Algorithmen existieren verschiedene Modelle,
 die jedoch alle wegen der Natur des Gossipings nicht um Konstrukte der
 Wahrscheinlichkeitsrechnung herumkommen.
\end_layout

\begin_layout Standard
Die meisten dieser Betrachtungen untersuchen ein solches System in ihrer
 Gesamtheit.
 Alternativ wird hier der Ansatz von Bakshi et al.
 in 
\begin_inset CommandInset citation
LatexCommand cite
key "6042051"

\end_inset

 vorgestellt, der zunächst die Interaktion zwischen zwei beliebigen Knoten
 betrachtet, das so genannte 
\emph on
Pairwise Interaction Model
\emph default
.
\end_layout

\begin_layout Standard
Es wird im Folgenden die Verbreitung eines Cache-Elements 
\begin_inset Formula $d$
\end_inset

 beobachtet.
 Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Pairwise-Interaction-Model"

\end_inset

 zeigt alle möglichen Zustände, die zwei beliebige Knoten 
\begin_inset Formula $A$
\end_inset

 und 
\begin_inset Formula $B$
\end_inset

 zueinander einnehmen können.
 Dabei beschreibe das Tupel 
\begin_inset Formula $(0,0)$
\end_inset

, dass weder 
\begin_inset Formula $A$
\end_inset

 noch 
\begin_inset Formula $B$
\end_inset

 das Cache-Element 
\begin_inset Formula $d$
\end_inset

 kennen.
 Das Tupel 
\begin_inset Formula $(0,1)$
\end_inset

 bezeichne, dass lediglich 
\begin_inset Formula $B$
\end_inset

 das Cache-Element kenne.
 Alle anderen Zustände sind analog definiert.
\end_layout

\begin_layout Standard
Die Übergänge beschreiben die Zustandsänderungen durch die Interaktion der
 beiden Knoten in einer Runde.
 Seien die Knoten zu Beginn im Zustand 
\begin_inset Formula $\left(0,1\right)$
\end_inset

.
 Durch die Interaktion der beiden Knoten kann nun folgendes passieren:
\end_layout

\begin_layout Itemize
Knoten 
\begin_inset Formula $B$
\end_inset

 verwirft am Ende ebenfalls 
\begin_inset Formula $d$
\end_inset

, weil er z.B.
 von Knoten 
\begin_inset Formula $A$
\end_inset

 einen besseren Wert erhalten hat, also sind die Knoten danach im Zustand
 
\begin_inset Formula $\left(0,0\right)$
\end_inset


\end_layout

\begin_layout Itemize
Knoten 
\begin_inset Formula $A$
\end_inset

 aktualisiert seinen Cache, so dass er nun auch 
\begin_inset Formula $d$
\end_inset

 im Cache hält, die Knoten sind dann im Zustand: 
\begin_inset Formula $\left(1,1\right)$
\end_inset


\end_layout

\begin_layout Itemize
Knoten 
\begin_inset Formula $A$
\end_inset

 aktualisiert zwar seinen Cache, aber Knoten 
\begin_inset Formula $B$
\end_inset

 verwirft 
\begin_inset Formula $d$
\end_inset

, die Knoten sind dann im Zustand 
\begin_inset Formula $\left(1,0\right)$
\end_inset


\end_layout

\begin_layout Itemize
Knoten 
\begin_inset Formula $A$
\end_inset

 aktualisiert seinen Cache nicht, aber 
\begin_inset Formula $B$
\end_inset

 verwirft das Element auch nicht, also bleiben die Knoten im Zustand 
\begin_inset Formula $\left(0,1\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /Users/davidbohn/Bachelor-Thesis/images/pairwise-interactions.pdf
	width 50col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Pairwise-Interaction-Model"

\end_inset

Zustände eines Knotenpaars im Pairwise Interaction Model (Abbildung 2 in
 
\begin_inset CommandInset citation
LatexCommand cite
key "6042051"

\end_inset

)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Unter welchen Bedingungen diese Übergänge nun gewählt werden ist vom implementie
rten Algorithmus, das heißt vor allem von der 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

PrepareMsg()
\end_layout

\end_inset

 und 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Update()
\end_layout

\end_inset

 Funktion, abhängig.
\end_layout

\begin_layout Standard
Da in diesem allgemeinen Fall nicht bekannt ist, wann ein Übergang stattfindet,
 werden Wahrscheinlichkeiten dafür angegeben.
 So gibt 
\begin_inset Formula $P\left(\begin{array}{c|c}
00 & 01\end{array}\right)$
\end_inset

 an, mit welcher Wahrscheinlichkeit der Zustandswechsel 
\begin_inset Formula $\left(0,1\right)\rightarrow\left(1,0\right)$
\end_inset

 stattfindet.
 Diese Wahrscheinlichkeit besteht zunächst aus zwei Komponenten: 
\begin_inset Formula $P_{select}$
\end_inset

 ist die Wahrscheinlichkeit, dass ein bestimmtes Element aus dem Cache zum
 Gossiping ausgewählt wird, also als Ergebnis von 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

PrepareMsg()
\end_layout

\end_inset

, und 
\begin_inset Formula $P_{drop}$
\end_inset

 ist die Wahrscheinlichkeit, dass dieses Element durch das Empfangene ersetzt
 wird (je nach 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Update()
\end_layout

\end_inset

-Implementierung).
\end_layout

\begin_layout Standard
Zusätzlich wird nun noch die Wahrscheinlichkeit 
\begin_inset Formula $P_{loss}$
\end_inset

 hinzugefügt.
 Während 
\begin_inset Formula $P_{select}$
\end_inset

 und 
\begin_inset Formula $P_{drop}$
\end_inset

 bisher alleine vom Protokoll definiert werden, sei 
\begin_inset Formula $P_{loss}$
\end_inset

 nun eine positive Wahrscheinlichkeit, dass ein Paket verloren geht.
 Beim Betrachteten Push-Pull Gossiping kann eine Nachricht an zwei Stellen
 verloren gehen: Die Push-Nachricht geht verloren, dann gibt es natürlich
 auch keine Pull-Nachricht mehr, oder nur die Pull-Nachricht geht verloren.
\end_layout

\begin_layout Standard
Genauere Betrachtungen dieser Verlustwahrscheinlichkeit zeigen, dass unter
 Berücksichtigung der Netzwerktopologie sich die Wahrscheinlichkeit 
\begin_inset Formula $P_{drop}$
\end_inset

 verändern kann.
 So hat nach 
\noun on
Bakshi
\noun default
 et al.
 Nachrichtenverlust in vollständig verbundenen Netzen keinerlei Auswirkungen
 auf die Verteilung der Daten, während bei einer lichten Topologie die Auswirkun
gen auf die gleichförmige Verteilung der Daten groß sein können.
\end_layout

\begin_layout Standard
Diese Analysemethode hat nun den Vorteil im Vergleich zu Betrachtungen des
 gesamten Systems wie beispielsweise beim Model Checking, dass der Einfluss
 von Nachrichtenverlust und Topologien aus dem eigentlichen Protokoll isoliert
 werden kann und durch statistische Daten beispielsweise in eine Simulation
 eingestreut werden kann, während die Beschreibung des Algorithmus davon
 unbetrachtet bleibt.
\end_layout

\begin_layout Subsection
Vor- und Nachteile von Gossiping
\end_layout

\begin_layout Standard
Wie auch bei Patterns des Software Designs ist auch Gossiping auf keinen
 Fall ein Algorithmen-Design, das für jeden Anwendungsfall die beste Lösung
 ist.
\end_layout

\begin_layout Standard
Aus diesem Grund werden hier einige Vor- und Nachteile von Gossiping-Algorithmen
 vorgestellt, die zeigen sollen, in welchen Situation die Verwendung von
 Gossiping-Algorithmen sinnvoll ist.
\end_layout

\begin_layout Standard
Die folgenden Argumente wurden von 
\noun on
Birman
\noun default
 in 
\begin_inset CommandInset citation
LatexCommand cite
key "Birman:2007:PLG:1317379.1317382"

\end_inset

 präsentiert.
\end_layout

\begin_layout Standard
Die meisten Gossiping-Algorithmen sind sehr einfach und mit nur wenig Code
 zu entwickeln, der dazu auf allen Knoten identisch ist.
 Dies ist auch aus dem bereits vorgestellten Framework ersichtlich, das
 lediglich die problemspezifische Implementierung von drei Methoden verlangt
 und davon abgesehen relativ wenige Zeilen Code benötigt.
\end_layout

\begin_layout Standard
Ein weiterer Vorteil von Gossiping ist die begrenzte Last, die ein einzelner
 Knoten zu bewältigen hat.
 Dies liegt zunächst an der Einteilung in feste Perioden, in denen Nachrichten
 ausgetauscht werden, und die Limitierung der Größe und Anzahl dieser.
 Da jeder Knoten in einer Periode nur einen weiteren kontaktieren kann und
 diesen zufällig auswählt, ist die Belastung für jeden einzelnen Knoten
 nahezu vernachlässigbar.
\end_layout

\begin_layout Standard
Wie bereits beschrieben wurde, interagieren die Knoten lediglich mit ihren
 Nachbarknoten.
 Dies führt dazu, dass diese unabhängig von der Netzwerktopologie sind.
 So lange ein ausreichend verbundener Netzwerkgraph vorliegt, wird auch
 der Gossiping-Algorithmus fehlerfrei funktionieren.
\end_layout

\begin_layout Standard
Dies führt auch dazu, dass leicht benachbarte Ressourcen gefunden werden
 können.
\end_layout

\begin_layout Standard
Schließlich sind Gossiping-Algorithmen resistent gegen vorrübergehende Netzwerkf
ehler.
 Dies ist nicht auf die Daten bezogen, für die diese Annahme zum Beispiel
 bei der Berechnung von Aggregaten nicht zwangsläufig zu halten ist, da
 diese u.U.
 in einer bestimmten Zeit an alle Knoten verteilt sein müssen, sondern auf
 das grobe Verhalten der Knoten.
 Ist ein einzelner Knoten in einer Runde nicht erreichbar, so wird in der
 nächsten Runde einfach der nächste Knoten kontaktiert.
 Da die Wahl des Nachbarknotens zufällig geschieht, ist auch gewährleistet,
 dass der zu diesem Zeitpunkt nicht erreichbare Knoten noch einmal kontaktiert
 werden wird.
\end_layout

\begin_layout Standard
Auf der anderen Seite sind Gossiping-Algorithmen aber auch fast immer langsamer
 als vergleichbare Lösungen, die kein Gossiping verwenden.
 Da die Nachrichtengröße eine obere Grenze hat und der Nachrichtenaustausch
 nur in periodischen Abständen stattfindet, eignet sich Gossiping nicht
 zur Übertragung zeitkritischer Informationen oder Informationen, die die
 maximale Nachrichtengröße überschreiten.
\end_layout

\begin_layout Standard
Ein weiterer Nachteil von Gossiping-Algorithmen ist, dass sie anfällig gegen
 plötzliche Häufungen von Ereignissen sind, die einen Gossip notwendig machen.
 Dies kann dazu führen, dass manche Informationen nie im ganzen Netzwerk
 verteilt werden, da sie von anderen Informationen verdrängt werden.
\end_layout

\begin_layout Standard

\noun on
Birman
\noun default
 sieht in Gossiping-Algorithmen vor allem ein effektives Werkzeug in Verbindung
 mit anderen Protokollen (
\begin_inset CommandInset citation
LatexCommand cite
key "Birman:2007:PLG:1317379.1317382"

\end_inset

).
 So kann mittels eines klassischem Algorithmus eine schnelle Verbreitung
 der Daten erreicht werden, die zwar vielleicht fehleranfälliger ist, der
 aber durch Gossiping, das mehr im Hintergrund läuft und kaum Bandbreite
 benötigt, deutlich robuster gemacht werden kann.
\end_layout

\begin_layout Standard
Des Weiteren wird Gossiping auch für eine Vielzahl von selbst-organisierenden
 und adaptiven Algorithmen, wie zur Konstruktion von Overlay-Netzwerken
 verwendet, bei denen somit über die zugrunde liegende Topologie nicht viel
 bekannt sein muss.
 Beispiele dafür sind CYCLON (
\begin_inset CommandInset citation
LatexCommand cite
key "cyclon"

\end_inset

) oder T-Man (
\begin_inset CommandInset citation
LatexCommand cite
key "tman"

\end_inset

).
\end_layout

\begin_layout Standard
Zusammenfassend kann also gesagt werden, dass Gossiping kein Allheilmittel
 ist und somit nicht zur Lösung jedes Problems verwendet werden sollte.
\end_layout

\begin_layout Standard
Es hat zwar verlockende Vorteile, wie die im Vergleich zu anderen Algorithmen
 einfache Umsetzung, ist dafür aber auch im Vergleich zu anderen Algorithmen
 deutlich langsamer.
\end_layout

\begin_layout Section
Technische Infrastruktur
\end_layout

\begin_layout Standard
Vor der Betrachtung der eigentlichen Implementierung wird im folgenden Abschnitt
 die technische Infrastruktur, die zur Realisierung verwendet wurde.
\end_layout

\begin_layout Standard
Im Rahmen dieser Arbeit wurde eine Implementierung des Gossiping-Algorithmus
 für das IoT-Lab vorgenommen.
 Dabei handelt es sich um eine Experimentierplattform für drahtlose Sensornetzwe
rke von großer Dimension, das eine praktische Evaluation von verteilten
 Algorithmen in verschiedenen Szenarien ermöglicht.
\end_layout

\begin_layout Standard
Genauer betrachtet wird im Anschluss noch der Funkstandard, der für die
 drahtlose Kommunikation im IoT-Lab verwendet wird, da einige Eigenschaften
 des Standards die Implementierung beeinflusst haben.
\end_layout

\begin_layout Subsection
Das IoT-Lab
\end_layout

\begin_layout Standard
Das FIT IoT-Lab
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.iot-lab.info
\end_layout

\end_inset


\end_layout

\end_inset

 ist eine Plattform, die vom FIT Konsortium, bestehend aus den fünf französische
n Universitäten Université Pierre et Marie Curie (UPMC), Inria, Université
 de Strasbourg, Institut Mines Télécom und CNRS, mit der Unterstützung verschied
ener weiterer Universitäten in Europa betrieben wird.
\end_layout

\begin_layout Standard
Auf verschiedene Standorte in Frankreich sind dabei weit über 2000 Sensorknoten
 verteilt, die in drei Systemarchitekturen aufgeteilt werden können.
 Neben dem Typ WSN430 (diese Knoten wurden vom Vorgängerprojekt des IoT-Labs,
 dem SensLab, übernommen) und den A8-Knoten, die sogar ein vollständiges
 Linux ausführen können, ist vor allem eine große Anzahl an Knoten vom Typ
 M3 vorhanden.
\end_layout

\begin_layout Standard
Die Implementierung, die im Rahmen dieser Arbeit vorgenommen wurde, ist
 ausschließlich für diesen Knotentyp gedacht, weshalb allein dieser und
 der Arbeitsablauf mit diesem Knotentyp hier kurz vorgestellt wird.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /Users/davidbohn/Bachelor-Thesis/resources/m3opennode.png
	width 80col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Foto-M3-Knoten"

\end_inset

Fotografie eines M3-Knotens (Quelle: IoT-Lab Website 
\begin_inset CommandInset citation
LatexCommand cite
key "m3opennode"

\end_inset

)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Hardware
\end_layout

\begin_layout Standard
Neben einer Reihe von Sensoren, die für diese Arbeit nicht verwendet wurden,
 ist das Board mit einem ARM-Mikroprozessor bestückt und verwendet einen
 802.15.4-Funkchip im 
\begin_inset Formula $2,4$
\end_inset

 GHz-Band zur Kommunikation.
\end_layout

\begin_layout Standard
Das Modul kann über den in Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Foto-M3-Knoten"

\end_inset

 gezeigten 
\begin_inset Quotes gld
\end_inset

IoT-LAB Connector
\begin_inset Quotes grd
\end_inset

 von außen mit neuen Programmen bestückt und gesteuert werden.
 Diese Schnittstelle fasst Stromversorgung und serielle Kommunikation zusammen
 und dient zur Verbindung mit einem so genannten Host-Knoten.
 Während die bisher vorgestellte Hardware von den Nutzern des IoT-Labs frei
 programmiert werden kann, ist der Zugriff auf den Host-Knoten nur eingeschränkt
 möglich.
 Dieser ist dafür verantwortlich, die Firmware auf die Knoten zu transportieren,
 den Knoten zu starten oder anzuhalten und auch den Energieverbrauch zu
 messen.
 Des Weiteren leitet dieser Host-Knoten die Ausgaben und Eingaben auf die
 serielle Schnittstelle eines Sensorknotens auf einen TCP-Port, der über
 das interne Netzwerk abzufragen ist.
\end_layout

\begin_layout Subsubsection
Schnittstellen in das IoT-Lab
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /Users/davidbohn/Bachelor-Thesis/images/iot_lab-infra-full.jpg
	width 90col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Schnittstellen-IoT"

\end_inset

Schnittstellen in das IoT-Lab (Quelle: IoT-Lab Website 
\begin_inset CommandInset citation
LatexCommand cite
key "iotlabplatformtools"

\end_inset

)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In diesem Abschnitt werden die diversen Methoden zur Interaktion mit dem
 IoT-Lab bzw.
 dessen Knoten vorgestellt.
\end_layout

\begin_layout Standard
Primär stellt das IoT-Lab eine REST-ähnliche Schnittstelle zur Verfügung.
 Über diese können zunächst Experimente erstellt werden.
 Ein Experiment besteht aus einer Auswahl an Knoten, mit denen gearbeitet
 werden kann, einer Zuordnung von Firmware-Dateien zu den Knoten, die vom
 Nutzer hochgeladen werden, und noch einer Zuordnung von Profilen, die genutzt
 werden können, um Verbrauchsdaten von den Host-Knoten abzurufen.
 Dieses Experiment kann dann zu einem gewählten Zeitpunkt oder so schnell
 wie möglich gestartet werden.
 Zu diesen Experimenten können dann über die Schnittstelle auch weitere
 Informationen wie die verwendeten Knoten, den Status usw.
 abgerufen werden.
\end_layout

\begin_layout Standard
Da die Interaktion über die REST-Schnittstelle aber in der Regel zu umständlich
 ist, bietet das IoT-Lab hierfür auch eine zweckerfüllende Web-Oberfläche
 an.
\end_layout

\begin_layout Standard
Um in einem laufenden Experiment mit den Knoten zu interagieren, gibt es
 die Möglichkeit, sich via SSH mit einem Linux-Server im IoT-Lab zu verbinden.
\end_layout

\begin_layout Standard
Die oben beschriebenen Host-Knoten besitzen eine Ethernet-Schnittstelle,
 über die sie im Netzwerk erreichbar sind und unter anderem die serielle
 Schnittstelle des Knotens spiegeln, mit dem sie über den IoT-Lab Connector
 verbunden sind.
\end_layout

\begin_layout Standard
Diese lassen sich auf dem Linux-Server aggregieren und die Daten, die empfangen
 wurden verarbeiten, oder Daten an einen oder alle Knoten senden.
\end_layout

\begin_layout Standard
Das IoT-Lab stellt dafür eine Reihe von Tools und Bibliotheken zur Verfügung,
 die die Arbeit mit diesen Schnittstellen vereinfachen.
\end_layout

\begin_layout Subsubsection
Betriebssystem der Knoten
\end_layout

\begin_layout Standard
Prinzipiell schreibt das IoT-Lab für die Knoten kein Betriebssystem vor,
 man könnte diese also auch ohne ein solches programmieren.
\end_layout

\begin_layout Standard
Das macht aber gerade die Arbeit mit der Hardware deutlich schwerer, weshalb
 es Portierungen verschiedener Betriebssysteme, die sich für ressourcensparende
 Echtzeit-Systeme eignen, gibt, die schon Treiber für die eingebauten Hardwareko
mponenten mitbringen.
 Die Knoten vom Typ A8 stechen hierbei heraus, da für diese sogar ein Port
 von Linux existiert.
 Aufgrund der vergleichsweise geringen Anzahl an verfügbaren Knoten und
 schlechteren Dokumentation, wird dies hier aber nicht verwendet.
\end_layout

\begin_layout Standard
Stattdessen gab es für die M3-Knoten drei Systeme, die hierfür in Frage
 kamen.
\end_layout

\begin_layout Description
RIOT RIOT
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://riot-os.org
\end_layout

\end_inset


\end_layout

\end_inset

 ist ein Echtzeit-Betriebssystem mit Multithreading, das für den Einsatz
 auf energiesparenden, verlässlichen und ressourcensparsamen Geräten des
 Internet of Things konzipiert wurde.
 Das Ziel ist dabei die Schaffung einer einheitlichen und einfach zu nutzenden
 API, die auf vielen Architekturen verwendet werden kann.
 Diese Eigenschaften und die Tatsache, dass die Entwicklung an RIOT von
 der Freien Universität Berlin stark vorangetrieben wird, machten es zuerst
 zu einem guten Kandidaten für die Verwendung.
 Jedoch waren die Treiber für die M3-Knoten zu Beginn der Implementierung
 noch nicht voll einsatzfähig, weshalb es nicht verwendet werden konnte.
\end_layout

\begin_layout Description
Contiki Contiki
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.contiki-os.org
\end_layout

\end_inset


\end_layout

\end_inset

 ist ebenfalls ein freies Betriebssystem, das auf die Verwendung in energiespare
nden und günstigen Mikrocontrollern ausgelegt ist.
 Jedoch liegen die Stärken des Systems vor allem darin, die Geräte in das
 Internet einzubinden, wofür es einen ausgereiften IP-Stack und verschiedene
 Funkprotokolle implementiert.
 Zusätzlich bietet es auch einen Simulator, der die Entwicklung von Anwendungen
 auf Basis des Systems deutlich vereinfacht.
 Jedoch ist auch die Dokumentation des IoT-Labs zu diesem Betriebssystem
 hauptsächlich auf die Einbindung eines Knotens in das Internet aus und
 es wird die Verwendung eines recht großen Protokollstacks erwartet, weshalb
 auch Contiki nicht verwendet wurde.
\end_layout

\begin_layout Description
FreeRTOS Zuletzt wurde das sehr kleine und einfache Betriebssystem FreeRTOS
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.freertos.org
\end_layout

\end_inset


\end_layout

\end_inset

 betrachtet.
 Seine größte Stärke ist, dass es an sich aus wenigen Dateien besteht, aber
 es trotzdem die wichtigsten Funktionalitäten bereitstellt, die von einem
 Betriebssystem auf solchen Systemen erwartet werden.
 Dazu gehören Mechanismen für Multithreading, ein Semaphor-Konstrukt und
 auch Software-Timer.
 Da es dazu noch sehr schnell ist, wurde es von den Betreuern des IoT-Lab
 zur primären Entwicklungsplattform für dieses gemacht und hat somit die
 besten Treiber für die Hardware des Knotens.
 Zusätzlich basieren auch weite Teile der Dokumentation auf FreeRTOS, was
 ebenfalls für die Verwendung dieses System für die Implementierung spricht.
\end_layout

\begin_layout Subsubsection
Topologien
\end_layout

\begin_layout Standard
Die Knoten des IoT-Labs sind auf verschiedene Standorte verteilt, die jeweils
 unterschiedliche räumliche Topologien aufweisen und somit auch ganz unterschied
liche Ergebnisse liefern können (siehe Abbildung 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Beispiele-für-Topologien"

\end_inset

).
\end_layout

\begin_layout Standard
Bei der Erstellung eines Experiments ist es möglich, anhand von Grundrissen
 der Räume die einzelnen Knoten auszuwählen die für das eigene Experiment
 verwendet werden sollen.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/davidbohn/Bachelor-Thesis/images/node-deployment-lille.png
	width 100col%

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/davidbohn/Bachelor-Thesis/resources/planMontbonnot.png
	width 100col%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Beispiele-für-Topologien"

\end_inset

Beispiele für Topologien im IoT-Lab, links in Lille, rechts in Grenoble
 (Quelle: 
\begin_inset CommandInset citation
LatexCommand cite
key "iotlablille"

\end_inset

 und 
\begin_inset CommandInset citation
LatexCommand cite
key "iotlabgrenoble"

\end_inset

 )
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Der 802.15.4 Funkstandard
\end_layout

\begin_layout Standard
Dieser Abschnitt stellt die grundlegenden Eigenschaften des 802.15.4 Funkstandards
 des IEEE vor.
 Als Grundlage dient dafür die Spezifikation der 
\begin_inset Quotes gld
\end_inset

Low-Rate Wireless Personal Area Networks
\begin_inset Quotes grd
\end_inset

 des IEEE vom 5.
 September 2011
\begin_inset CommandInset citation
LatexCommand cite
key "802.15.4"

\end_inset

.
\end_layout

\begin_layout Standard
Ein Wireless Personal Area Network (WPAN) dient dabei dazu energiesparend
 und günstig Informationen über relativ kurze Distanzen zu übertragen ohne
 dabei eine größere Infrastruktur vorauszusetzen wie beispielsweise beim
 Wireless Local Area Network (WLAN).
\end_layout

\begin_layout Standard
Der Standard definiert hierfür physikalische Schichten (PHY-Layer) für verschied
ene Frequenzbänder und die Zugriffskontrolle auf das Medium (medium access
 control/MAC-Layer).
 Die wichtigsten Frequenzbänder, die von dem Standard gedeckt werden und
 die in Deutschland von Relevanz sind, sind dabei das 868 MHz-Band sowie
 das 2,4 GHz-Band.
\end_layout

\begin_layout Standard
Es wird dabei zwischen zwei Typen von Netzwerkkomponenten unterschieden.
 Auf der einen Seite gibt es das Reduced Function Device (RFD), das nur
 sehr simple Aufgaben übernimmt.
 In einer Heimautomatisierungslösung kann dies z.B.
 ein Lichtschalter sein, der eben nur dann, wenn der Schalter gedrückt wurde,
 diese Änderung an einen so genannten Koordinator weiterleiten muss, oder
 eine Lampe, die dann angeht, wenn vom Koordinator eine entsprechende Nachricht
 kommt.
\end_layout

\begin_layout Standard
Dieser Koordinator ist zwangsläufig ein Full Function Device (FFD) und kann
 im Gegensatz zum RFD, das nur mit seinem zugeordneten FFD kommunizieren
 kann, mit all seinen Nachbarn in seinem Umkreis kommunizieren.
 Daher ist es für die Umsetzung des Gossiping-Algorithmus naheliegend, alle
 Knoten als Full Function Device anzusehen.
\end_layout

\begin_layout Subsubsection
Topologien
\end_layout

\begin_layout Standard
Es werden zwei mögliche Topologien vorgeschrieben.
\end_layout

\begin_layout Standard
Die Stern-Topologie sieht einen zentralen Koordinator-Knoten vor, der z.B.
 die Orchestrierung in einem Heimautomatisierungssystem übernimmt.
 Alle Knoten kennen nur diesen Koordinator, weshalb diese Topologie für
 ein drahtloses Sensornetzwerk ungeeignet ist.
\end_layout

\begin_layout Standard
Die zweite Topologie ist eine Peer-to-Peer-Topologie, die für das Anwendungsgebi
et der drahtlosen Sensornetze deutlich besser geeignet ist.
 Hierbei kommuniziert ein Knoten nicht nur mit dem Koordinator, den es trotzdem
 geben kann, sondern auch mit den Nachbarn, die er erreichen kann.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:PHY-Layer"

\end_inset

PHY-Layer
\end_layout

\begin_layout Standard
Die PHY-Layer ist zunächst nicht von großer Bedeutung für die Implementierung,
 wir benötigen jediglich einige Werte, die der PHY-Layer uns bereitstellt.
 Diese umfassen die Energy detection (ED) sowie der Link Quality Indicator
 (LQI).
 Die Energy Detection bestimmt die Signalstärke auf einem bestimmten Funkkanal
 ausgehend von einer minimalen Signalstärke.
 Das ist also die induzierte Energie durch die Datenübertragung.
 Dieser wird für weitere Protokollschichten, die in dem Standard definiert
 werden, benötigt.
 Der Link Quality Indicator dagegen ist eine Metrik, die für die Anwendungsschic
ht definiert wird und im PHY-Layer selbst nicht weiter verwendet wird, und
 soll die Stärke und Qualität der Funkübertragung bei Empfang eines Pakets
 charakterisiert werden.
 Daher wird diese Messung auch für jedes Paket durchgeführt und ergibt gleichmäß
ig verteilte Werte im Bereich von 
\begin_inset Formula $0x00$
\end_inset

 und 
\begin_inset Formula $0xff$
\end_inset

, die mit der niedrigsten bzw.
 höchsten Signalstärke belegt werden, die verwendbar sind.
 Zusätzlich definiert das Protokoll auch Methoden des 
\emph on
clear channel assessments
\emph default
, das heißt der Bestimmung, ob ein Funkkanal gerade belegt wird.
 Diese beziehen z.B.
 ein, ob der ED-Wert einen bestimmten Wert überschreitet, das heißt, dass
 irgendwas von einer bestimmten Stärke empfangen wird, oder auch, ob es
 auch ein valides Signal ist.
\end_layout

\begin_layout Subsubsection
MAC-Layer
\end_layout

\begin_layout Standard
Die Aufgabe des MAC-Layer ist es sicherzustellen, dass es nicht zu Kollisionen
 kommt, das heißt, dass ein Knoten ein Paket sendet, obwohl gerade ein anderes
 Paket übertragen wird, das dadurch beschädigt werden würde.
\end_layout

\begin_layout Standard
Es gibt eine Vielzahl von Algorithmen, um diese Aufgabe zu erfüllen, der
 Standard beschreibt zwei Mechanismen: CSMA-CA und ALOHA.
\end_layout

\begin_layout Standard
ALOHA ist ein Anfang der 1970er-Jahre an der Universität von Hawaii entwickeltes
 Protokoll zur Datenübertragung auf geteilten Medien, welches zuerst von
 
\noun on
Abramson
\noun default
 in 
\begin_inset CommandInset citation
LatexCommand cite
key "Abramson:1970:ASA:1478462.1478502"

\end_inset

 beschrieben wurde.
 Es sieht vor, dass ein Knoten Knoten nicht auf das Freiwerden des Mediums
 wartet, sondern seine Nachricht sofort sendet.
 Sollte es dabei zu einer Kollision kommen, weil schon ein anderer Teilnehmer
 sendet, wird das vom Empfänger erkannt und eine Neuübertragung angefordert.
 Alternativ lassen sich auch feste Zeitslots festlegen, in denen ein Knoten
 eine Nachricht sendet, welche allerdings auch nicht unbedingt einem Knoten
 alleine gehören, sondern auch von anderen Knoten genutzt werden können,
 wodurch sich aber Pakete höchstens vollständig überlagern können und andere
 Slots davon nicht beeinflusst werden (vgl.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Roberts:1975:APS:1024916.1024920"

\end_inset

).
 Das ist ausreichend für Netzwerke, in denen nur selten Daten übertragen
 werden, aber ungeeignet für diesen Anwendungsfall, da im Laufe der Zeit
 sehr viele Nachrichten übertragen werden, weshalb es zu sehr vielen Neuübertrag
ungen kommen würde.
\end_layout

\begin_layout Standard
Daher sei nun alternativ der Paketversand unter Verwendung von CSMA-CA (
\emph on
Carrier Sense Medium Access-Colision Avoidance
\emph default
) vorgestellt.
\end_layout

\begin_layout Standard
Wie bereits in Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:PHY-Layer"

\end_inset

 beschrieben, existiert die Möglichkeit zu entscheiden, ob das Medium derzeit
 frei ist oder Daten von einem anderen Knoten derzeit gesendet werden über
 das clear channel assessment (CCA).
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "mathescape=true"
inline false
status open

\begin_layout Plain Layout

func unslottedCSMA():
\end_layout

\begin_layout Plain Layout

	NB = 0, BE = macMinBE
\end_layout

\begin_layout Plain Layout

	bool channel_idle = false
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	while (!channel_idle):
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		wait random($2^{BE} - 1$) * backoffPeriod
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

		channel_idle = perform_cca()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		if (!channel_idle):
\end_layout

\begin_layout Plain Layout

			NB = NB + 1
\end_layout

\begin_layout Plain Layout

			BE = min(BE+1, macMaxBE)
\end_layout

\begin_layout Plain Layout

			if (NB > macMaxCSMABackoffs?):
\end_layout

\begin_layout Plain Layout

				return false
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	return true
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Pseudocode-des-CSMA-CA-Algorithm"

\end_inset

Pseudocode des CSMA-CA-Algorithmus nach Abbildung 11 in 
\begin_inset CommandInset citation
LatexCommand cite
key "802.15.4"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Da die Implementierung des Gossiping-Algorithmus keinen PAN-Knoten verwendet,
 wird hier ausschließlich der unslotted CSMA-CA-Algorithmus beschrieben,
 der als Pseudocode in Algorithmus 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Pseudocode-des-CSMA-CA-Algorithm"

\end_inset

 formuliert wurde.
\end_layout

\begin_layout Standard
Zunächst wird ein zufälliges Intervall gewartet, das durch 
\begin_inset Formula $\text{random}\left(2^{BE}-1\right)\cdot\mathtt{backoffPeriod}$
\end_inset

 bestimmt wird.
 Die 
\begin_inset Formula $\mathtt{backoffPeriod}$
\end_inset

 ist dabei das Produkt aus 
\begin_inset Formula $\mathtt{aUnitBackoffPeriod}$
\end_inset

, also der Anzahl der Symbole (kleinste übertragene Dateneinheit), die gewartet
 wird, und der Übertragungsdauer eines Symbols, die im verwendeten 
\begin_inset Formula $2.45\,GHz$
\end_inset

-Band bei 
\begin_inset Formula $16\mu s$
\end_inset

 liegt.
\end_layout

\begin_layout Standard
Anschließend wird durch das 
\emph on
clear channel assessment
\emph default
 überprüft, ob der Kanal frei ist.
\end_layout

\begin_layout Standard
Ist dies der Fall, wird der Paketversand erlaubt, ansonsten wird der Vorgang
\end_layout

\begin_layout Standard
\begin_inset Formula $\mathtt{macMaxCSMABackoffs}-1$
\end_inset

-mal wiederholt.
 Dieser Wert kann zwischen 
\begin_inset Formula $0$
\end_inset

 und 
\begin_inset Formula $5$
\end_inset

 sein, als Standardwert ist 
\begin_inset Formula $4$
\end_inset

 angegeben.
\end_layout

\begin_layout Standard
Dabei wird der Backoff Exponent 
\begin_inset Formula $BE$
\end_inset

 inkrementiert, solange er höchstens so groß ist wie 
\begin_inset Formula $\mathtt{macMaxBE}$
\end_inset

(standardmäßig 5).
\end_layout

\begin_layout Standard
Wird bei keiner Wiederholung ein freier Kanal vorgefunden, so wird der Sendevorg
ang abgebrochen.
\end_layout

\begin_layout Standard
Durch das garantierte Warten einer bestimmten Zeit beim Versand eines Pakets
 wird die Datenrate des Mediums reduziert.
 Für die Kalibrierung des Gossiping-Algorithmus ist dieses Warten auch nicht
 uninteressant, wenn das Intervall festgelegt werden soll, in denen der
 aktive Thread Nachrichten verschickt.
 So wird schon beim ersten Sendeversuch mit den Standardwert im schlimmsten
 Fall
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
16\mu s\cdot\textrm{aUnitBackoffPeriod}\cdot\left(2^{BE}-1\right) & = & 16\mu s\cdot20\cdot7\\
 & = & 2240\mu s
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
gewartet.
\end_layout

\begin_layout Paragraph
Anmerkung
\end_layout

\begin_layout Standard
Im ursprünglichen Standarddokument 
\begin_inset CommandInset citation
LatexCommand cite
key "802.15.4"

\end_inset

 wurde statt 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

BE = min(BE+1, macMaxBE)
\end_layout

\end_inset

 die Zuweisung
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

BE = min(BE+1, macMinBE)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
angegeben.
 Dieser Fehler wurde in einem Amendment vom 16.
 April 2012 (
\begin_inset CommandInset citation
LatexCommand cite
key "802.15.4-2012"

\end_inset

) behoben.
\end_layout

\end_body
\end_document
