#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 503
\begin_document
\begin_header
\origin unavailable
\textclass scrartcl
\begin_preamble
\usepackage{minted}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language ngerman
\language_package default
\inputencoding utf8
\fontencoding default
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "cmtt" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation 0bp
\quotes_language german
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Section
Grundlagen verteilter Systeme
\end_layout

\begin_layout Standard
In diesem Kapitel werden notwendige Definitionen vorgestellt, die im Folgenden
 zur Beschreibung des Gossiping-Algorithmus und zur Diskussion der Implementieru
ng verwendet werden.
\end_layout

\begin_layout Standard
Dazu wird zunächst die mathematische Darstellung eines verteilten Systems
 beschrieben, wie sie im Rahmen dieser Arbeit angenommen wird.
\end_layout

\begin_layout Subsection
Beschreibung eines drahtlosen Sensornetzwerks
\end_layout

\begin_layout Standard
Verteilte Systeme lassen sich durch ungerichtete Graphen der Form 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

 beschreiben.
 Dabei sei die Knotenmenge 
\begin_inset Formula $V$
\end_inset

 die Menge aller Sensoren sowie 
\begin_inset Formula $E\subseteq V\times V$
\end_inset

 die Menge aller Kanäle zwischen den Knoten.
\end_layout

\begin_layout Standard
Ein Kanal 
\begin_inset Formula $\{u,v\}\in E$
\end_inset

 mit 
\begin_inset Formula $u,v\in V$
\end_inset

 beschreibt dabei eine bidirektionale Nachbarschaftsrelation zwischen zwei
 Knoten.
 Dies bedeutet, dass sowohl der Knoten 
\begin_inset Formula $u$
\end_inset

 den Knoten 
\begin_inset Formula $v$
\end_inset

 als auch reziprok der Knoten 
\begin_inset Formula $v$
\end_inset

 dem Knoten 
\begin_inset Formula $u$
\end_inset

 kennt und diesem Nachrichten schicken kann.
\end_layout

\begin_layout Standard
Des Weiteren beschreibe die Funktion 
\begin_inset Formula $lq\,:\,E\rightarrow\mathbb{R}$
\end_inset

 die Übertragungsqualität eines Kanals.
 Dabei sei sie so definiert, dass sie einen Vergleich über die Verlässlichkeit
 verschiedener Kanäle zulasse.
\end_layout

\begin_layout Standard
Wir werden diese Funktion genauer im Abschnitt 
\begin_inset CommandInset ref
LatexCommand eqref
reference "subsec:neighbourhood-relationship"

\end_inset

 betrachten.
\begin_inset Note Note
status open

\begin_layout Plain Layout
vielleicht hier weglassen oder zumindest umschreiben!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Damit können wir nun die Nachbarschaft 
\begin_inset Formula $N\left(v\right)$
\end_inset

 eines Knoten 
\begin_inset Formula $v$
\end_inset

 als die Menge aller Knoten beschreiben, die von einem Knoten via eines
 Kanals direkt erreichbar sind:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
\mathcal{N}\left(v\right) & = & \left\{ \begin{array}{c|c}
u\in V & \left\{ v,u\right\} \in E\end{array}\right\} \label{eq:neighbourhood}
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
Es kann sinnvoll sein, die Nachbarschaft noch einzuschränken, indem man
 einen Grenzwert für 
\begin_inset Formula $lq\left(\left\{ u,v\right\} \right)$
\end_inset

 festlegt, d.h.
 nur Kanäle zulässt, die eine bestimmte Qualität haben.
\begin_inset Note Note
status open

\begin_layout Plain Layout
sollte man das noch machen?
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Methoden zur Kommunikation zwischen Knoten
\end_layout

\begin_layout Standard
Nach der Konstruktion des Netzwerks können die Knoten nun entsprechend Daten
 austauschen.
\begin_inset Note Note
status open

\begin_layout Plain Layout
asynchrones (nicht-blockierendes) send, blockierendes receive
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In den folgenden theoretischen Betrachtungen verwenden wir dafür die Operationen
 
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

send
\end_layout

\end_inset

 und 
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

receive
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Ein Knoten 
\begin_inset Formula $v$
\end_inset

 kann nur eine Nachricht an einen Nachbarn 
\begin_inset Formula $p$
\end_inset

 aus 
\begin_inset Formula $N\left(v\right)$
\end_inset

 schicken.
 Die sende-Operation erfolgt asynchron, d.h.
 der Sender wird nicht blockiert bis der Empfänger die Nachricht erhalten
 hat.
 Eine solche Sende-Operation einer Nachricht 
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline true
status open

\begin_layout Plain Layout

m
\end_layout

\end_inset

 an einen Nachbarn 
\begin_inset Formula $p$
\end_inset

 beschreiben wir in unseren theoretischen Betrachtungen mit:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

send m to p
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Auf der Empfangsseite muss ein Knoten sich explizit empfangsbereit zeigen.
 Er wartet dabei nicht auf eine Nachricht von einem bestimmten Kanal, sondern
 ist für Nachrichten auf allen Kanälen offen.
\end_layout

\begin_layout Standard
Eine Empfangsoperation ist blockierend, das heißt der empfangende Knoten
 kann in dieser Zeit keine anderen Befehle ausführen.
\end_layout

\begin_layout Standard
Im Pseudocode wird im Folgenden der Nachrichtenempfang in einen Puffer 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

b
\end_layout

\end_inset

 wie folgt dargestellt:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

receive b
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Es wird nützlich sein, eine Struktur zur Verfügung zu haben, die es uns
 erlaubt, Nachrichten von einem bestimmten Partner zu empfangen.
 Wir führen dabei das folgende Konstrukt ein:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

receive b from p
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Dieser Aufruf blockiert den aufrufenden Knoten so lange, bis eine Nachricht
 von dem angegebenen Knoten 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

p
\end_layout

\end_inset

 empfangen wurde.
 Andere Nachrichten von anderen Knoten werden in diesem Falle verworfen.
\end_layout

\begin_layout Section
Der Gossiping-Algorithmus
\end_layout

\begin_layout Standard
In diesem Kapitel wird nun zunächst die Grundidee des Gossiping-Algorithmus
 vorgestellt und dann konkrete Umsetzungen dieses Verfahrens dargestellt.
 Hauptsächlich werden dabei Aspekte beleuchtet, die für die Nachrichtenverteilze
it von Relevanz sind, somit ist für uns vor allem von Interesse, wann die
 Information im gesamten Netzwerk verteilt ist bzw.
 wann der Gossiping-Algorithmus terminiert.
\end_layout

\begin_layout Standard
Der Abschnitt wird mit der Vorstellung, verschiedener Algorithmen abgeschlossen,
 die den Gossiping-Algorithmus verwenden, um die folgende Vorstellung der
 Implementierung zu motivieren.
\end_layout

\begin_layout Subsection
Die Grundidee
\end_layout

\begin_layout Standard
Die Grundidee dieses Algorithmus steckt schon in seinem Namen: Informationen
 werden 
\begin_inset Quotes gld
\end_inset

tratschend
\begin_inset Quotes grd
\end_inset

 (dt.
 für to gossip) verbreitet.
 Man stelle sich folgende Situation vor: In einem Büro mit 
\begin_inset Formula $N$
\end_inset

 Mitarbeitern erhält Mitarbeiter 
\begin_inset Formula $i$
\end_inset

 die Nachricht, dass zum Ende des Jahres einige Mitglieder gekündigt werden.
 Dies ist natürlich eine Nachricht von solcher Prägnanz, dass er diese seinen
 beiden Kollegen, die ihm im Büro gegenübersitzen, sofort mitteilen muss.
 Somit sind auch diese beiden Kollegen im Besitz dieser Information, die
 sie dann wieder weiter an einige wenige Kollegen tragen.
 Somit verbreitet sich die Nachricht schnell mit einer Konstante beschränktem
 Aufwand pro Mitarbeiter im ganzen Netzwerk.
\end_layout

\begin_layout Standard
Im Kontext der verteilten Systeme ersetzen wir nun die Mitarbeiter nun durch
 Knoten und die möglichen Kollegen, mit denen ein Mitarbeiter kommunizieren
 kann, stellen wir durch Kanäle zwischen verschiedenen Knoten dar.
\end_layout

\begin_layout Standard
Erhält ein Knoten neue Informationen, sei es durch äußere Einwirkungen oder
 durch Beendigung einer Berechnung, so wird er diese an eine zufällige Teilmenge
 seiner Nachbarn verteilen, welche ebenfalls wieder jeweils eine Teilmenge
 von eigenen Nachbarn auswählen und mit diesen einen Gossip durchführen.
\end_layout

\begin_layout Standard
Wir formalisieren zunächst die Anforderungen, die wir an ein Protokoll stellen,
 das als Gossiping-Protokoll bezeichnet werden kann, um dann anhand dieser
 Anforderungen den Algorithmus weiter zu formalisieren und zu analysieren.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Anforderungen-Gossiping"

\end_inset

Anforderungen an einen Gossiping-Algorithmus
\end_layout

\begin_layout Standard
Wir bezeichnen einen Algorithmus im Folgenden als Gossiping-Algorithmus,
 wenn er die folgenden Anforderungen, die von 
\noun on
Birman
\noun default
 in 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Quelle: The Promise, and Limitations, of Gossip Protocols 
\end_layout

\end_inset

 vorgeschlagen wurden.
 Ähnliche Anforderungen wurden auch von 
\noun on
Shah
\noun default
 in 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Quelle: Gossiping Algorithms
\end_layout

\end_inset

 gestellt:
\end_layout

\begin_layout Enumerate
Kern des Protokolls sind periodische und paarweise Interaktionen zwischen
 verschiedenen Prozessen.
\end_layout

\begin_layout Enumerate
Die Information, die durch in Punkt 1 beschriebene Interaktionen versendet
 wird, ist von beschränkter Größe.
\end_layout

\begin_layout Enumerate
Wenn zwei Prozesse interagieren, ändert sich der Zustand eines oder beider
 Prozesse insofern, dass es den Status des anderen reflektiert.
\end_layout

\begin_layout Enumerate
Eine verlässliche Kommunikation wird nicht vorausgesetzt.
\end_layout

\begin_layout Enumerate
Die Interaktionsfrequenz ist im vergleich zu den Latenzen des Nachrichtenaustaus
chs gering.
\end_layout

\begin_layout Enumerate
Die Auswahl des Nachbarknotens, mit dem interagiert wird, geschieht auf
 irgendeine Art und Weise zufällig.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: Kurze Erläuterung zu den Punkten, Punkt 6 ist auf Nachbarn beschränkt
 wegen The Gossiping Book.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Gossiping als epidemischer Algorithmus
\end_layout

\begin_layout Standard
Der Gossiping-Algorithmus, oftmals auch als Rumor Spreading-Algorithmus
 bezeichnet, wird der Klasse der epidemischen Algorithmen zugeordnet.
 Die Idee der epidemischen Algorithmen, die von 
\noun on
Demers
\noun default
 et al.
 in 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Quelle: Epidemic Algorithms for Replicated Database Maintenance
\end_layout

\end_inset

 vorgestellt wurde, beruht auf den mathematischen Modellen der epidemischen
 Verbreitung von Viren und anderer Krankheitserreger, die von Virologen
 verwendet wird, um die Verbreitung von Krankheitserregern vorauszusagen.
\end_layout

\begin_layout Standard
Während aber der Virologe gemeinhin versucht, die Verbreitung des Virus
 möglichst einzudämmen, so möchte man bei epidemischen Algorithmen hingegen
 einen Verlauf gestalten, der eine möglichst schnelle Verbreitung der Informatio
nen gewährleistet.
\end_layout

\begin_layout Subsubsection
Knotenzustände
\end_layout

\begin_layout Standard
Wir betrachten zunächst, welche Zustände ein Knoten in unserem Netzwerk
 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

 haben kann.
 Diese Zustände werden in 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Quelle: Epidemic Algorithms for Replicated Database Maintenance
\end_layout

\end_inset

 vorgeschlagen und sind der Epidemologie entnommen.
 Jeder Knoten 
\begin_inset Formula $v\in V$
\end_inset

 hat zu jedem Zeitpunkt einen dieser drei Zustände:
\end_layout

\begin_layout Description
infiziert
\begin_inset space \space{}
\end_inset

(infected) Der Knoten besitzt eine Information, die er an andere Knoten
 weitergeben kann und will, und wird dies von nun an versuchen.
\end_layout

\begin_layout Description
empfänglich
\begin_inset space \space{}
\end_inset

(susceptible) Der Knoten besitzt noch keine neuen Informationen, er ist
 also für die Information anderer Knoten empfänglich.
\end_layout

\begin_layout Description
entfernt(removed) Der Knoten hat die neuen Informationen erhalten, will
 diese aber nicht mehr weiter verbreiten.
\end_layout

\begin_layout Standard
Im Folgenden sei 
\begin_inset Formula $I$
\end_inset

 die Menge der infizierten Knoten in 
\begin_inset Formula $V$
\end_inset

, 
\begin_inset Formula $S$
\end_inset

 die Menge der empfänglichen Knoten und 
\begin_inset Formula $R$
\end_inset

 die Menge der entfernten Knoten:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
I & = & \left\{ \begin{array}{c|c}
v\in V & v\text{ ist infiziert}\end{array}\right\} \\
S & = & \left\{ \begin{array}{c|c}
v\in V & v\text{ ist empfänglich}\end{array}\right\} \\
R & = & \left\{ \begin{array}{c|c}
v\in V & v\text{ ist entfernt}\end{array}\right\} 
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Da jeder Knoten höchstens einen Zustand haben darf, gilt 
\begin_inset Formula 
\begin{eqnarray}
I\cap S\cap R & = & \emptyset\label{eq:subsetcut}
\end{eqnarray}

\end_inset

.
 Jeder Knoten muss aber auch einen dieser drei Zustände haben, so dass 
\begin_inset Formula 
\begin{eqnarray}
I\cup S\cup R & = & V\label{eq:subsetconjunct}
\end{eqnarray}

\end_inset

.
\end_layout

\begin_layout Subsubsection
Modellierung von Gossiping als epidemischer Algorithmus
\end_layout

\begin_layout Standard
Wir betrachten nun, wie das Rumor Spreading (also Gossiping), nach 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Quelle: Epidemic Algorithms for Replicated Database Maintenance
\end_layout

\end_inset

 als epidemischer Algorithmus beschrieben werden kann.
\end_layout

\begin_layout Standard
Ein Knoten 
\begin_inset Formula $v\in I$
\end_inset

, d.h.
 ein Knoten im Zustand 
\emph on
infiziert
\emph default
, wählt fortlaufend einen Knoten aus 
\begin_inset Formula $\mathcal{N}\left(v\right)$
\end_inset

 aus und schickt ihm seine neuen Informationen.
 Der Empfänger antwortet mit seinen bisherigen Informationen.
\end_layout

\begin_layout Standard
Kannte der Empfänger die Informationen bereits, so hört der Knoten 
\begin_inset Formula $v$
\end_inset

 mit Wahrscheinlichkeit 
\begin_inset Formula $\frac{1}{k}$
\end_inset

 auf, Informationen auszutauschen und geht in den Zustand 
\emph on
entfernt
\emph default
 über.
\end_layout

\begin_layout Standard
Ein empfänglicher Knoten, der Informationen erhält, geht in den Zustand
 
\emph on
infiziert
\emph default
 über und beginnt nun ebenfalls einen zufälligen Nachbarn auszuwählen und
 diesem die eigene Information mitzuteilen.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /Users/davidbohn/Bachelor-Thesis/images/3-2-infection-states.pdf
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Zustandsübergänge beim Gossiping beschrieben als epidemischen Vorgang (eigene
 Abbildung)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Analyse von diesem Gossiping-Modell
\end_layout

\begin_layout Standard
Das lässt nun die Frage aufkommen, wann das System in einen Zustand kommt,
 in dem keine weiteren Nachrichten ausgetauscht werden.
\end_layout

\begin_layout Standard
Wir nehmen hierbei an, dass die Kanäle zwischen den Knoten verlustfrei sind
 und die Sende- und Empfangsoperationen atomar sind.
 Dies sind gerade in drahtlosen Sensornetzen sehr starke Einschränkungen,
 die aber zu der Zeit und für den Anwendungszweck von 
\noun on
Demers 
\noun default
et al.
 hinnehmbar waren.
\end_layout

\begin_layout Standard
Dazu betrachten wir, wie sich die Anteile der 
\emph on
infizierten
\emph default
, 
\emph on
empfänglichen
\emph default
 und 
\emph on
entfernten
\emph default
 Knoten an der gesamten Knotenmenge 
\begin_inset Formula $V$
\end_inset

 über die Zeit ändert.
 Sei 
\begin_inset Formula $i=\frac{\left|I\right|}{\left|V\right|}$
\end_inset

 der Anteil der infizierten Knoten, 
\begin_inset Formula $s=\frac{\left|S\right|}{\left|V\right|}$
\end_inset

 der Anteil der empfänglichen Knoten sowie 
\begin_inset Formula $r=\frac{\left|R\right|}{\left|V\right|}$
\end_inset

 der Anteil der entfernten Knoten.
 Aus 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:subsetcut"

\end_inset

 und 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:subsetconjunct"

\end_inset

 folgt daher:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
i+r+s & = & 1\label{eq:epidemic-fractionsum}
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
Nach 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Quelle: Epidemic Algorithms for Replicated Database Maintenance
\end_layout

\end_inset

 lässt sich die Verbreitung der Information nun über zwei Differentialgleichunge
n beschreiben:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
\frac{ds}{dt} & = & -s\cdot i\label{eq:susceptible-change}\\
\frac{di}{dt} & = & s\cdot i-\frac{1}{k}\left(1-s\right)\cdot i\label{eq:infected-change}
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
Gleichung 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:susceptible-change"

\end_inset

 beschreibt dabei die Änderung des Anteils der Empfänglichen Knoten an 
\begin_inset Formula $V$
\end_inset

 pro Zeiteinheit.
 Das Produkt beschreibt dabei, den Anteil der Empfänglichen, die von den
 infizierten Knoten ausgewählt werden und die neue Information erhalten,
 dadurch verlassen sie den Zustand 
\emph on
empfänglich
\emph default
, weshalb diese Menge immer abnimmt.
\end_layout

\begin_layout Standard
Analog haben wir den reziproken Term in Gleichung 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:infected-change"

\end_inset

, da diese Knoten ja nun 
\emph on
infiziert
\emph default
 sind und diese Menge dadurch größer wird.
 Zusätzlich gibt es aber noch den Fall, dass ein infizierter Knoten einen
 Knoten kontaktiert hat, der die Information bereits kennt.
 Wie oben beschrieben hört dieser dann mit Wahrscheinlichkeit 
\begin_inset Formula $\frac{1}{k}$
\end_inset

 auf, die Nachricht zu verteilen und ist dann nicht mehr 
\emph on
infiziert
\emph default
, sondern geht in den Zustand 
\emph on
entfernt
\emph default
 über.
 Der Anteil der Knoten, die nicht empfänglich sind, d.h.
 bei denen diese Entscheidung stattfindet, ist durch 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:epidemic-fractionsum"

\end_inset

 als 
\begin_inset Formula $1-s$
\end_inset

 gegeben.
\end_layout

\begin_layout Standard
Wir wollen nun geeignete Werte für 
\begin_inset Formula $k$
\end_inset

 finden, die eine möglichst zuverlässige Verteilung der Daten im Netz sicherstel
lt.
 Zur Lösung wird dazu in 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Quelle: Epidemic Algorithms for Replicated Database Maintenance
\end_layout

\end_inset

 das Verhältnis 
\begin_inset Formula $\frac{di}{ds}$
\end_inset

 gebildet.
 Dadurch entfernen wir die zeitliche Komponente und erhalten:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
\frac{di}{ds} & = & -\frac{s\cdot i-\frac{1}{k}\left(1-s\right)\cdot i}{s\cdot i}\\
 & = & -1+\frac{\left(1-s\right)\cdot i}{k\cdot s\cdot i}\\
 & = & -1+\frac{i-s\cdot i}{k\cdot s\cdot i}\\
 & = & -1+\frac{\cancel{i}}{k\cdot s\cdot\cancel{i}}-\frac{\cancel{s\cdot i}}{k\cdot\cancel{s\cdot i}}\\
 & = & -\frac{k+1}{k}+\frac{1}{k\cdot s}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Dadurch können wir nun über Integration eine Funktion 
\begin_inset Formula $i\left(s\right)$
\end_inset

 erhalten, die uns für einen Anteil an empfänglichen Knoten einen Anteil
 an infizierten Knoten bestimmt:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
i\left(s\right) & = & -\frac{k+1}{k}s+\frac{1}{k}\ln s+c\label{eq:i-nach-integration}
\end{eqnarray}

\end_inset


\end_layout

\begin_layout Standard
Zur Eliminierung der Integrationskonstanten 
\begin_inset Formula $c$
\end_inset

 betrachten wir die Anfangsbedingung 
\begin_inset Formula $i\left(1-\epsilon\right)=\epsilon$
\end_inset

.
 Für große Knotenmengen konvergiert 
\begin_inset Formula $\epsilon$
\end_inset

 gegen null, somit ergibt sich für 
\begin_inset Formula $c$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
c & = & \frac{k+1}{k}
\end{eqnarray*}

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
häh?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Durch Einsetzen in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:i-nach-integration"

\end_inset

 erhalten wir somit:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
i\left(s\right) & = & \frac{k+1}{k}\left(1-s\right)+\frac{1}{k}\ln s
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
Wenn wir nun wissen wollen, wann es keine infizierten Knoten mehr gibt,
 also das System inaktiv geworden ist, müssen wir diese Funktion null setzen
 und erhalten damit folgende implizite Gleichung:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray*}
s & = & e^{-\left(k+1\right)\left(1-s\right)}
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Standard
In Abbildung 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Anteil-empfänglicher-Knoten"

\end_inset

 ist das Verhalten der Gleichung bei sich änderndem 
\begin_inset Formula $k$
\end_inset

 dargestellt.
 Der erste Term des Exponenten ist der dominante Term, weshalb dieser den
 Kurvenverlauf maßgeblich vorgibt.
 Der zweite Term (
\begin_inset Formula $1-s$
\end_inset

) ist stets im Intervall 
\begin_inset Formula $\left[0,1\right]$
\end_inset

 und wird somit schnell vom Term 
\begin_inset Formula $k+1$
\end_inset

 verdrängt, weshalb die Abbildung einen guten Ansatzpunkt liefert.
\end_layout

\begin_layout Standard
Wählt man somit zum Beispiel 
\begin_inset Formula $k=1$
\end_inset

, d.h.
 ein infizierter Knoten geht sofort in den Zustand entfernt über, sobald
 er einen nicht empfänglichen Knoten kontaktiert, so sind am Ende noch immer
 ca.
 
\begin_inset Formula $20\%$
\end_inset

 der Knoten empfänglich, haben also die Information nicht bekommen und können
 sie auch nicht mehr erhalten.
 Erhöht man 
\begin_inset Formula $k$
\end_inset

 aber auf 
\begin_inset Formula $2$
\end_inset

, so sind dies lediglich nur noch 
\begin_inset Formula $6\%$
\end_inset

, die die Information nicht erhalten.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways true
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/davidbohn/Bachelor-Thesis/images/3-2-decay.pdf
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Anteil-empfänglicher-Knoten"

\end_inset

Anteil empfänglicher Knoten nach Entfernung des letzten Infizierten über
 
\begin_inset Formula $k$
\end_inset

 (eigene Abbildung)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Fazit
\end_layout

\begin_layout Standard
Implementiert man den Algorithmus also auf diese einfache Weise, so ist
 nicht unbedingt sichergestellt, dass am Ende alle Knoten die Nachricht
 erhalten haben.
 Wir möchten aber hier gerade die Zeit analysieren, bis alle Knoten die
 Nachricht erhalten haben.
\end_layout

\begin_layout Standard
Des Weiteren hat dieser Ansatz das Problem, dass er verlässliche Datenkanäle
 annimmt.
 Eine solche Annahme ist aber für drahtlose Sensornetzwerke nicht haltbar,
 weshalb im Folgenden Möglichkeiten vorgestellt werden, wie man mit dieser
 Problematik umgehen kann.
 
\end_layout

\begin_layout Subsection
Gossiping über unzuverlässige Kanäle
\end_layout

\begin_layout Subsubsection
Verallgemeinerung und Formalisierung des Gossiping-Algorithmus
\end_layout

\begin_layout Standard
Für die weiteren Betrachtungen des Gossiping-Algorithmus wird auf das Framework
 zurückgegriffen, das von 
\noun on
Bakhshi
\noun default
 et al.
 in 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Quelle: A Modeling Framework for Gossip-based Information Spread
\end_layout

\end_inset

 vorgestellt wurde.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},mathescape=true"
inline false
status open

\begin_layout Plain Layout

wait $
\backslash
Delta t$ time units;
\end_layout

\begin_layout Plain Layout

$p$ = RandomPeer();
\end_layout

\begin_layout Plain Layout

$
\backslash
sigma$ = PrepareMsg();
\end_layout

\begin_layout Plain Layout

send $
\backslash
sigma$ to $p$;
\end_layout

\begin_layout Plain Layout

wait until receive $
\backslash
sigma_p$ from $p$;
\end_layout

\begin_layout Plain Layout

Update($
\backslash
sigma$, $
\backslash
sigma_p$);
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\ttfamily},mathescape=true"
inline false
status open

\begin_layout Plain Layout

wait until receive $
\backslash
sigma_p$;
\end_layout

\begin_layout Plain Layout

$
\backslash
sigma$ = PrepareMsg();
\end_layout

\begin_layout Plain Layout

send $
\backslash
sigma$ to sender($
\backslash
sigma_p$);
\end_layout

\begin_layout Plain Layout

Update($
\backslash
sigma$, $
\backslash
sigma_p$);
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Gossiping-Framework-nach-Bakhshi"

\end_inset

Gossiping-Framework nach 
\noun on
Bakhshi
\noun default
 et al.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Das Framework sieht vor, dass ein Knoten zwei Threads ausführt - einen aktiven
 und einen passiven Thread.
 Des Weiteren besitzt jeder Knoten einen lokalen Cache, der die Daten des
 Knotens beinhaltet, die durch das Gossiping verbreitet und verändert werden.
\end_layout

\begin_layout Standard
Der passive Thread ist dabei dafür zuständig, eine Nachricht von einem Nachbarn
 zu empfangen, mit dem eigenen Informationen im entsprechenden Cache-Segment
 zu antworten und den eigenen Cache entsprechend zu aktualisieren.
\end_layout

\begin_layout Standard
Der aktive Thread wird in einem festen Intervall 
\begin_inset Formula $\Delta t$
\end_inset

 ausgeführt.
 Alle Knoten verwenden dabei dasselbe Intervall.
 Alle 
\begin_inset Formula $\Delta t$
\end_inset

 Zeiteinheiten wählt der Knoten einen Nachbarn aus, wählt einen entsprechenden
 Teil des Caches (oder den ganzen) aus, schickt diesen an den Knoten und
 wartet auf die Antwort, die von dessem passiven Thread geschickt werden,
 um anhand dieser den eigenen Cache zu aktualisieren.
\end_layout

\begin_layout Standard
Die Funktionen 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RandomPeer()
\end_layout

\end_inset

, 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

PrepareMsg()
\end_layout

\end_inset

 und 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Update()
\end_layout

\end_inset

 sind dabei entsprechend davon abhängig, wie der Algorithmus genau funktionieren
 soll, also wofür man den Gossiping-Algorithmus verwenden will.
\end_layout

\begin_layout Standard
Die Funktion 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RandomPeer()
\end_layout

\end_inset

 wählt aus der Menge 
\begin_inset Formula $N\left(v\right)$
\end_inset

 einen Vertreter aus.
 Diese Auswahl muss eine zufällige Komponente beinhalten.
 Eine Auswahl des Caches wird mit der Funktion 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

PrepareMsg()
\end_layout

\end_inset

 generiert.
 In manchen Anwendungen ist der Cache nicht weiter unterteilbar, weil er
 z.B.
 aus nur einem Wert besteht, dann wird immer der gesamte Cache übertragen.
 Andererseits kann durch entsprechende Definition der 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

PrepareMsg()
\end_layout

\end_inset

 Funktion auch eine Pull-Strategie realisiert werden, indem man ein leeres
 Cache-Element verschickt, auf das der passive Thread dann mit seinen Daten
 antwortet.
\end_layout

\begin_layout Standard
Die Aktualisierung des eigenen Caches bei Empfang eines Datenpakets geschieht
 in der 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

Update()
\end_layout

\end_inset

-Funktion.
 Über diese Funktion lässt sich an diesem Punkt nicht mehr sagen, als dass
 sie Anforderung Nr.
 3 aus Abschnitt 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Anforderungen-Gossiping"

\end_inset

 erfüllen muss, das heißt sie darf den eigenen Cache nur insofern ändern,
 dass diese Änderung auf Basis des empfangenen Pakets geschieht.
\end_layout

\begin_layout Standard
Die weiteren Anforderungen 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Anforderungen-Gossiping"

\end_inset

 werden bei vorsichtiger Definition der drei eben beschriebenen Funktionen
 ebenfalls durch das Framework erfüllt.
\end_layout

\begin_layout Standard
Der aktive Thread stellt sicher, dass es eine periodische, paarweise Interaktion
 zwischen den Prozessen gibt.
 Solange das von 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

PrepareMsg()
\end_layout

\end_inset

 generierte Paket eine maximale Größe hat, so wird auch die Anforderung
 Nr.
 2 erfüllt, dass der Datenaustausch immer eine maximale Größe hat.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Anforderung Nr.
 4!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Durch eine entsprechend große Wahl von 
\begin_inset Formula $\Delta t$
\end_inset

 wird auch Anforderung Nr.
 5 erfüllt, also dass die Frequenz des Austauschs deutlich geringer ist
 als die Latenz der Austauschs.
 Bei der praktischen Umsetzung muss dann dieser Wert entsprechend an die
 Hardware angepasst werden.
\end_layout

\begin_layout Standard
Anforderung Nr.
 6, die zufällige Auswahl der Kommunikationspartner, wird durch die Funktion
 
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

RandomPeer()
\end_layout

\end_inset

 erfüllt, insofern sie der Spezifikation entsprechend implementiert wurde.
\end_layout

\begin_layout Subsubsection
Abgrenzung zur epidemischen Betrachtung
\end_layout

\begin_layout Itemize
Beschreibung des Gossiping Algorithmus bzw.
 der Klasse der epidemischen Algorithmen
\end_layout

\begin_layout Itemize
Vorstellung des Prototyp-Algorithmus, der als Blaupause dient
\end_layout

\begin_deeper
\begin_layout Itemize
Vergleich mit Formulierung über zentralen Tick
\end_layout

\end_deeper
\begin_layout Itemize
Abgrenzung
\end_layout

\begin_deeper
\begin_layout Itemize
Push
\end_layout

\begin_layout Itemize
Pull
\end_layout

\begin_layout Itemize
Push-Pull
\end_layout

\end_deeper
\begin_layout Section
Technische Infrastruktur
\end_layout

\begin_layout Standard
Vor der Betrachtung der eigentlichen Implementierung wird im folgenden Abschnitt
 die technische Infrastruktur, die zur Realisierung verwendet wurde.
\end_layout

\begin_layout Standard
Dabei handelt es sich um das IoT-Lab, eine Experimentierplattform für drahtlose
 Sensornetze, die über verschiedene Standorte in Frankreich verteilt ist.
\end_layout

\begin_layout Subsection
Das IoT-Lab
\end_layout

\begin_layout Itemize
Was ist das IoT-Lab?
\end_layout

\begin_layout Itemize
Welche Hardware stellt es zur Verfügung?
\end_layout

\begin_layout Itemize
Workflow?
\end_layout

\begin_layout Subsection
Der 802.15.4 Funkstandard
\end_layout

\begin_layout Itemize
Was ist Teil des Standards, was nicht?
\end_layout

\begin_layout Itemize
Anwendungsgebiet
\end_layout

\end_body
\end_document
